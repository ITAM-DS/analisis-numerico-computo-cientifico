
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3.4 Ecuaciones no lineales</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.5f77b4aec8189eecf79907ce328c390d.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe,.cell"
        const thebe_selector_input = "pre,.cell_input div.highlight"
        const thebe_selector_output = ".output,.cell_output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="4.1 Programación lineal (PL) y método símplex" href="../../4.optimizacion_en_redes_y_prog_lineal/4.1/Programacion_lineal_y_metodo_simplex.html" />
    <link rel="prev" title="3.3 Ejemplos de problemas UCO, introducción a Constrained Inequality and Equality Optimization (CIEO) y puntos interiores" href="../3.3/Ejemplos_problemas_UCO_e_intro_CIEO_y_PI.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
      <img src="../../_static/logo.png" class="logo" alt="logo">
      
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../README.html">
   Optimización
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  1. Cómputo científico
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../1.computo_cientifico/1.1/Analisis_numerico_y_computo_cientifico.html">
   1.1 Análisis numérico y cómputo científico
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../1.computo_cientifico/1.2/Sistema_de_punto_flotante.html">
   1.2 Sistema de punto flotante
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../1.computo_cientifico/1.3/Normas_vectoriales_y_matriciales.html">
   1.3 Normas vectoriales y matriciales
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../1.computo_cientifico/1.4/Condicion_de_un_problema_y_estabilidad_de_un_algoritmo.html">
   1.4 Condición de un problema y estabilidad de un algoritmo
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../1.computo_cientifico/1.5/Definicion_de_funcion_continuidad_derivada.html">
   1.5 Definición de función, continuidad y derivada
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../1.computo_cientifico/1.6/Polinomios_de_Taylor_y_diferenciacion_numerica.html">
   1.6 Polinomios de Taylor y diferenciación numérica
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../1.computo_cientifico/1.7/Integracion_numerica.html">
   1.7 Integración Numérica
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  2. Cómputo matricial
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../2.computo_matricial/2.1/Operaciones_y_transformaciones_basicas_del_Algebra_Lineal_Numerica.html">
   2.1 Operaciones y transformaciones básicas del Álgebra Lineal Numérica
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../2.computo_matricial/2.2/Eigenvalores_y_eigenvectores.html">
   2.2 Eigenvalores y eigenvectores
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../2.computo_matricial/2.3/Algoritmos_y_aplicaciones_de_eigenvalores_eigenvectores_de_una_matriz.html">
   2.3 Algoritmos y aplicaciones de eigenvalores y eigenvectores de una matriz
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../2.computo_matricial/2.4/Valores_vectores_singulares_y_algoritmos_para_calcular_la_SVD.html">
   2.4 Valores, vectores singulares y algoritmos para calcular la SVD
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  3. Optimización convexa y ecuaciones no lineales
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../3.1/Definicion_de_problema_optimizacion_conjuntos_y_funciones_convexas.html">
   3.1 Definición de problemas de optimización, conjuntos y funciones convexas
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../3.2/Algoritmos_de_descenso_y_busqueda_de_linea_en_uco.html">
   3.2 Algoritmos de descenso y búsqueda de línea en
   <em>
    Unconstrained Convex Optimization
   </em>
   (UCO)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../3.3/Ejemplos_problemas_UCO_e_intro_CIEO_y_PI.html">
   3.3 Ejemplos de problemas UCO, introducción a
   <em>
    Constrained Inequality and Equality Optimization
   </em>
   (CIEO) y puntos interiores
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   3.4 Ecuaciones no lineales
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  4. Optimización en redes y programación lineal
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../4.optimizacion_en_redes_y_prog_lineal/4.1/Programacion_lineal_y_metodo_simplex.html">
   4.1 Programación lineal (PL) y método símplex
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../4.optimizacion_en_redes_y_prog_lineal/4.2/Definiciones_generales_de_flujo_en_redes.html">
   4.2 Definiciones generales de flujo en redes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../4.optimizacion_en_redes_y_prog_lineal/4.3/Ejemplo_metodo_simplex_de_redes.html">
   4.3 Ejemplo del método símplex de redes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../4.optimizacion_en_redes_y_prog_lineal/4.4/Dualidad_lema_de_Farkas_condiciones_KKT_de_optimalidad.html">
   4.4 Dualidad, lema de Farkas y condiciones de Karush-Kuhn-Tucker (KKT) de optimalidad
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../4.optimizacion_en_redes_y_prog_lineal/4.5/Metodo_primal_dual_de_BL.html">
   4.5 Método primal-dual de barrera logarítmica (BL)
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  5. Optimización de código
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../5.optimizacion_de_codigo/5.1/introduccion_optimizacion_de_codigo.html">
   5.1 Introducción a optimización de código
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../5.optimizacion_de_codigo/5.2/Herramientas_de_lenguajes_y_del_SO_para_perfilamiento_e_implementaciones_de_BLAS.html">
   5.2 Herramientas de lenguajes de programación y del sistema operativo para perfilamiento e implementaciones de BLAS
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../5.optimizacion_de_codigo/5.3/Compilacion_a_C.html">
   5.3 Compilación a C
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../5.optimizacion_de_codigo/5.4/Computo_en_paralelo_usando_CPUS_en_SMC.html">
   5.4 Cómputo en paralelo usando CPUs en un sistema de memoria compartida (SMC)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../5.optimizacion_de_codigo/5.5/Computo_en_paralelo_usando_GPUS_en_SMC.html">
   5.5 Cómputo en paralelo usando GPUs en un sistema de memoria compartida (SMC)
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  6. Algoritmos de optimización convexa
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../6.algoritmos_optimizacion_convexa/6.1/Problemas_UCO.html">
   6.1 Problemas tipo
   <em>
    Unconstrained Convex Optimization
   </em>
   (UCO)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../6.algoritmos_optimizacion_convexa/6.2/Problemas_CECO.html">
   6.2 Problemas tipo
   <em>
    Constrained Equality Convex Optimization
   </em>
   (CECO)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../6.algoritmos_optimizacion_convexa/6.3/Problemas_CIECO.html">
   6.3 Problemas tipo
   <em>
    Constrained Equality and Inequality Convex Optimization
   </em>
   (CIECO)
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  7. Temas selectos
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../7.temas_selectos/7.1/Optimizacion_estocastica.html">
   7.1 Optimización estocástica
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../7.temas_selectos/7.2/Metodos_cuasi_Newton.html">
   7.2 Métodos cuasi Newton
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/3.optimizacion_convexa/3.4/Ecuaciones_no_lineales.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/palmoreck/dockerfiles-for-binder/jupyterlab_optimizacion_2?urlpath=lab/tree/analisis-numerico-computo-cientifico/libro_optimizacion/temas/3.optimizacion_convexa/3.4/Ecuaciones_no_lineales.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        <button type="button" class="btn btn-secondary topbarbtn"
            onclick="initThebeSBT()" title="Launch Thebe" data-toggle="tooltip" data-placement="left"><i
                class="fas fa-play"></i><span style="margin-left: .4em;">Live Code</span></button>
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#sistemas-de-ecuaciones-lineales">
   Sistemas de ecuaciones lineales
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#interpretacion-geometrica">
     Interpretación geométrica
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#algoritmos-para-resolver-sistemas-de-ecuaciones-lineales">
     Algoritmos para resolver sistemas de ecuaciones lineales
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#algoritmos-para-sistemas-triangulares">
     Algoritmos para sistemas triangulares
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#algoritmos-para-sistemas-no-triangulares">
     Algoritmos para sistemas no triangulares
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sistemas-de-ecuaciones-lineales-square-underdetermined-overdetermined">
     Sistemas de ecuaciones lineales
     <em>
      square
     </em>
     ,
     <em>
      underdetermined
     </em>
     ,
     <em>
      overdetermined
     </em>
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id1">
   Ecuaciones no lineales
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#criterios-de-paro-escala-de-la-variable-x-y-de-la-funcion-f">
   Criterios de paro, escala de la variable
   <span class="math notranslate nohighlight">
    \(x\)
   </span>
   y de la función
   <span class="math notranslate nohighlight">
    \(f\)
   </span>
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metodos-para-resolver-ecuaciones-no-lineales-de-funciones-f-mathbb-r-rightarrow-mathbb-r">
   Métodos para resolver ecuaciones no lineales de funciones
   <span class="math notranslate nohighlight">
    \(f: \mathbb{R} \rightarrow \mathbb{R}\)
   </span>
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#metodo-de-biseccion">
     Método de bisección
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#algoritmo-metodo-de-biseccion">
     Algoritmo: método de bisección
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#metodo-de-newton-o-newton-raphson">
     Método de Newton o Newton-Raphson
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ejemplo">
     Ejemplo
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#algoritmo-metodo-de-newton-para-resolver-una-ecuacion-no-lineal">
     Algoritmo: método de Newton para resolver una ecuación no lineal
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id2">
     Ejemplo
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#algoritmo-metodo-general-cuasi-newton-hibrido-para-resolver-una-ecuacion-no-lineal">
     Algoritmo: método general cuasi-Newton híbrido para resolver una ecuación no lineal
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#una-nota-sobre-problemas-unconstrained-optimization-uo">
   Una nota sobre problemas
   <em>
    Unconstrained Optimization
   </em>
   (UO)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#sistema-de-ecuaciones-no-lineales">
   Sistema de ecuaciones no lineales
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metodo-de-newton-para-ecuaciones-no-lineales-de-funciones-f-mathbb-r-n-rightarrow-mathbb-r-n">
   Método de Newton para ecuaciones no lineales de funciones
   <span class="math notranslate nohighlight">
    \(f: \mathbb{R}^n \rightarrow \mathbb{R}^n\)
   </span>
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#algoritmo-metodo-de-newton-multidimensional-para-resolver-un-sistema-de-ecuaciones-no-lineales">
     Algoritmo: método de Newton multidimensional para resolver un sistema de ecuaciones no lineales
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id3">
     Ejemplo
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ejemplo-componentes-principales">
     Ejemplo: componentes principales
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="ecuaciones-no-lineales">
<span id="ecnl"></span><h1>3.4 Ecuaciones no lineales<a class="headerlink" href="#ecuaciones-no-lineales" title="Permalink to this headline">¶</a></h1>
<div class="admonition-notas-para-contenedor-de-docker admonition">
<p class="admonition-title">Notas para contenedor de docker:</p>
<p>Comando de docker para ejecución de la nota de forma local:</p>
<p>nota: cambiar <code class="docutils literal notranslate"><span class="pre">&lt;ruta</span> <span class="pre">a</span> <span class="pre">mi</span> <span class="pre">directorio&gt;</span></code> por la ruta de directorio que se desea mapear a <code class="docutils literal notranslate"><span class="pre">/datos</span></code> dentro del contenedor de docker y <code class="docutils literal notranslate"><span class="pre">&lt;versión</span> <span class="pre">imagen</span> <span class="pre">de</span> <span class="pre">docker&gt;</span></code> por la versión más actualizada que se presenta en la documentación.</p>
<p><code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span> <span class="pre">--rm</span> <span class="pre">-v</span> <span class="pre">&lt;ruta</span> <span class="pre">a</span> <span class="pre">mi</span> <span class="pre">directorio&gt;:/datos</span> <span class="pre">--name</span> <span class="pre">jupyterlab_optimizacion</span> <span class="pre">-p</span> <span class="pre">8888:8888</span> <span class="pre">-d</span> <span class="pre">palmoreck/jupyterlab_optimizacion:&lt;versión</span> <span class="pre">imagen</span> <span class="pre">de</span> <span class="pre">docker&gt;</span></code></p>
<p>password para jupyterlab: <code class="docutils literal notranslate"><span class="pre">qwerty</span></code></p>
<p>Detener el contenedor de docker:</p>
<p><code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">stop</span> <span class="pre">jupyterlab_optimizacion</span></code></p>
<p>Documentación de la imagen de docker <code class="docutils literal notranslate"><span class="pre">palmoreck/jupyterlab_optimizacion:&lt;versión</span> <span class="pre">imagen</span> <span class="pre">de</span> <span class="pre">docker&gt;</span></code> en <a class="reference external" href="https://github.com/palmoreck/dockerfiles/tree/master/jupyterlab/optimizacion">liga</a>.</p>
</div>
<hr class="docutils" />
<p>Nota generada a partir de <a class="reference external" href="https://www.dropbox.com/s/dfwk0y04ksgfilv/3.5.Aplicaciones_del_algebra_lineal_numerica.pdf?dl=0">liga1</a>, <a class="reference external" href="https://www.dropbox.com/s/6zree47e1u3p5wx/Ecuaciones_no_lineales.pdf?dl=0">liga2</a>.</p>
<div class="tip admonition">
<p class="admonition-title">Al final de esta nota el y la lectora:</p>
<ul class="simple">
<li><p>Distinguirá la diferencia entre métodos abiertos y cerrados a partir del método de bisección y método de Newton.</p></li>
<li><p>Conocerá algunos criterios de paro utilizados en métodos iterativos y la importancia de considerar la escala de las variables y la función a la que se le desea calcular sus raíces o ceros.</p></li>
<li><p>Fortalcerá lo revisado en la nota de <a class="reference internal" href="../3.2/Algoritmos_de_descenso_y_busqueda_de_linea_en_uco.html#adbluco"><span class="std std-ref">algoritmos de descenso y búsqueda de línea en UCO</span></a> al relacionar resolver problemas de optimización sin restricciones con resolver sistemas de ecuaciones no lineales.</p></li>
<li><p>Aprenderá que el método de Newton es un método con convergencia local cuadrática bajo ciertas suposiciones y al que se le deben añadir metodologías para convergencia desde cualquier punto inicial (convergencia global) dando lugar a métodos cuasi-Newton híbridos.</p></li>
</ul>
</div>
<div class="section" id="sistemas-de-ecuaciones-lineales">
<h2>Sistemas de ecuaciones lineales<a class="headerlink" href="#sistemas-de-ecuaciones-lineales" title="Permalink to this headline">¶</a></h2>
<p>Las ecuaciones lineales tienen importantes aplicaciones en todas las áreas de la ciencia. La teoría del álgebra lineal nos permite tener resultados universales de las mismas y son una herramienta importante para aproximaciones a ecuaciones no lineales. Por ejemplo, al considerar pequeñas perturbaciones en un punto, un sistema no lineal puede típicamente aproximarse por un sistema lineal en una vecindad local del punto. Sin embargo, la linearización sólo describe propiedades locales y para un análisis global de problemas no lineales otras técnicas se requieren. Tales métodos comúnmente utilizan esquemas iterativos para gradualmente aproximar la solución.</p>
<div class="admonition-definicion admonition">
<p class="admonition-title">Definición</p>
<p>En general un sistema de ecuaciones lineal es de la forma:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{ccc} 
a_{11}x_1 + a_{12}x_2 + \cdots + a_{1n}x_n  &amp;= &amp; b_1 \\ 
a_{21}x_1 + a_{22}x_2 +  \cdots + a_{2n}x_n &amp;= &amp; b_2 \\ 
\vdots &amp; &amp; \\ 
a_{m1}x_1 + a_{m2}x_2 + \cdots + a_{mn}x_n &amp;=&amp; b_m 
\end{array}
\end{split}\]</div>
<p>donde: las <span class="math notranslate nohighlight">\(x_i\)</span>’s son las incógnitas y las <span class="math notranslate nohighlight">\(a_i\)</span>’s y <span class="math notranslate nohighlight">\(b_i\)</span>’s son constantes conocidas.</p>
<p>Las entradas <span class="math notranslate nohighlight">\(a_{ij}\)</span>’s son nombradas <strong>coeficientes del sistema</strong> y forman a la <strong>matriz del sistema</strong> <span class="math notranslate nohighlight">\(A \in \mathbb{R}^{m \times n}\)</span>. El conjunto de <span class="math notranslate nohighlight">\(b_i\)</span>’s se le nombra <strong>lado derecho del sistema</strong> y forma al <strong>vector de lado derecho</strong> <span class="math notranslate nohighlight">\(b \in \mathbb{R}^{m}\)</span>. Así, el sistema se escribe como <span class="math notranslate nohighlight">\(Ax = b\)</span>.</p>
<p>Si todas las <span class="math notranslate nohighlight">\(b_i\)</span>’s son iguales a <span class="math notranslate nohighlight">\(0\)</span> el sistema se le nombra <strong>homogéneo</strong> si no se cumple esto se le nombra <strong>no homogéneo</strong>.</p>
</div>
<p>La teoría del álgebra lineal nos ayuda a determinar que existen solamente <strong>3 posibilidades para solución del sistema anterior:</strong></p>
<ul class="simple">
<li><p><strong>Una única solución:</strong> sólo existe uno y sólo un conjunto de valores de <span class="math notranslate nohighlight">\(x_i\)</span>’s que satisfacen todas las ecuaciones simultáneamente.</p></li>
<li><p><strong>Ninguna solución:</strong> no existe ningún conjunto de valores de <span class="math notranslate nohighlight">\(x_i\)</span>’s que satisfacen todas las ecuaciones simultáneamente (el conjunto solución es vacío).</p></li>
<li><p><strong>Infinitas soluciones:</strong> hay una infinidad de valores distintos de las <span class="math notranslate nohighlight">\(x_i\)</span>’s que satisfacen todas las ecuaciones simultáneamente.</p></li>
</ul>
<div class="admonition-definicion admonition">
<p class="admonition-title">Definición</p>
<p>En el caso de una o infinitas soluciones el sistema de ecuaciones lineales se nombra consistente o no singular, si no existe solución se nombra inconsistente o singular.</p>
</div>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<p>Es sencillo probar que si un sistema tiene más de una solución entonces tiene una infinidad de soluciones. Esto contrasta con sistemas de ecuaciones no lineales donde pueden existir para tales sistemas un número finito de soluciones mayor a uno.</p>
</div>
<div class="section" id="interpretacion-geometrica">
<h3>Interpretación geométrica<a class="headerlink" href="#interpretacion-geometrica" title="Permalink to this headline">¶</a></h3>
<p>Resolver un sistema de ecuaciones lineales equivale a encontrar la intersección entre rectas, planos o hiperplanos (2,3 o n dimensiones respectivamente). Por ejemplo para un caso de dos dimensiones se tiene:</p>
<img src="https://dl.dropboxusercontent.com/s/p92z7zlquo1adbm/algebra_lineal_1.jpg?dl=0" heigth="700" width="700">
<p>El inciso a) representa un sistema de ecuaciones lineales sin solución, el inciso b) infinitas soluciones (en el dibujo ligeramente se desplazó hacia abajo una de las rectas para mostrar ambas) y el inciso c) una única solución.</p>
</div>
<div class="section" id="algoritmos-para-resolver-sistemas-de-ecuaciones-lineales">
<span id="algsel"></span><h3>Algoritmos para resolver sistemas de ecuaciones lineales<a class="headerlink" href="#algoritmos-para-resolver-sistemas-de-ecuaciones-lineales" title="Permalink to this headline">¶</a></h3>
<p>Existen una gran cantidad de algoritmos para resolver sistemas de ecuaciones lineales. Típicamente se elige el algoritmo de acuerdo a las características de los coeficientes de la matriz del sistema y sus dimensiones.</p>
</div>
<div class="section" id="algoritmos-para-sistemas-triangulares">
<h3>Algoritmos para sistemas triangulares<a class="headerlink" href="#algoritmos-para-sistemas-triangulares" title="Permalink to this headline">¶</a></h3>
<p>Son sistemas cuya matriz del sistema es triangular inferior o superior. Un sistema triangular inferior se resuelve con el <strong>método de sustitución hacia delante</strong>. Si es triangular superior se resuelve con el <strong>método de sustitución hacia atrás</strong>.</p>
</div>
<div class="section" id="algoritmos-para-sistemas-no-triangulares">
<h3>Algoritmos para sistemas no triangulares<a class="headerlink" href="#algoritmos-para-sistemas-no-triangulares" title="Permalink to this headline">¶</a></h3>
<p>Para sistemas de ecuaciones lineales más generales (no tienen estructura identificable) se tienen los <strong>métodos iterativos</strong> y <strong>directos o basados en factorizaciones matriciales</strong>.</p>
<p>Entre los directos o basados en factorizaciones matriciales se encuentran:</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Ver <a class="reference internal" href="../../2.computo_matricial/2.4/Valores_vectores_singulares_y_algoritmos_para_calcular_la_SVD.html#matrizsdpositiva"><span class="std std-ref">definición</span></a> de una matriz simétrica definida positiva.</p>
</div>
<ul class="simple">
<li><p>Eliminación Gaussiana o factorización LU.</p></li>
<li><p>Factorización de Cholesky (la matriz del sistema debe ser un elemento en <span class="math notranslate nohighlight">\(\mathbb{S}^n_{++}\)</span> simétrica positiva definida)</p></li>
<li><p>Factorización QR.</p></li>
<li><p>Descomposición en valores singulares o SVD.</p></li>
</ul>
<p>y como ejemplo de los iterativos están:</p>
<ul class="simple">
<li><p>Jacobi.</p></li>
<li><p>Gauss-Seidel.</p></li>
<li><p>Gradiente conjugado (la versión que se aplica a matrices del sistema simétricas requiere que tales matrices estén en <span class="math notranslate nohighlight">\(\mathbb{S}^n_{++}\)</span>).</p></li>
</ul>
<p>Ambos métodos: iterativos y directos o basados en factorizaciones matriciales encuentran sistemas de ecuaciones equivalentes a partir de operaciones básicas del álgebra lineal.</p>
<div class="admonition-definicion admonition">
<p class="admonition-title">Definición</p>
<p>Dos sistemas de ecuaciones lineales son equivalentes si tienen el mismo conjunto solución.</p>
</div>
</div>
<div class="section" id="sistemas-de-ecuaciones-lineales-square-underdetermined-overdetermined">
<h3>Sistemas de ecuaciones lineales <em>square</em>, <em>underdetermined</em>, <em>overdetermined</em><a class="headerlink" href="#sistemas-de-ecuaciones-lineales-square-underdetermined-overdetermined" title="Permalink to this headline">¶</a></h3>
<p>Entre las características que definen el problema a resolver y el tipo de algoritmo a usar se encuentran las dimensiones de una matriz.</p>
<div class="admonition-definicion admonition">
<p class="admonition-title">Definición</p>
<p>Si la matriz del sistema tiene más renglones que columnas, <span class="math notranslate nohighlight">\(m &gt; n\)</span>, se tiene un sistema <em><strong>overdetermined</strong></em>, si tiene más columnas que renglones, <span class="math notranslate nohighlight">\(m &lt; n\)</span>, se nombra <em><strong>underdetermined</strong></em> y si tiene el mismo número de renglones y columnas, <span class="math notranslate nohighlight">\(m=n\)</span>, se nombra <em><strong>square</strong></em>.</p>
</div>
<p>Los sistemas de ecuaciones lineales <em>overdetermined</em> en general no tienen solución si <span class="math notranslate nohighlight">\(b \notin \text{Im}(A)\)</span> con <span class="math notranslate nohighlight">\(\text{Im}(A)\)</span> espacio columna de <span class="math notranslate nohighlight">\(A\)</span>. Por esto se busca resolver un <strong>problema de mínimos cuadrados</strong> de la forma:</p>
<div class="math notranslate nohighlight">
\[\displaystyle \min_{x \in \mathbb{R}^n} ||Ax-b||_2\]</div>
<p>con única solución si <span class="math notranslate nohighlight">\(A\)</span> es de <em>rank</em> completo.</p>
<p>Los sistemas de ecuaciones lineales <em>underdetermined</em> pueden tener infinitas soluciones o ninguna solución. En el caso que <span class="math notranslate nohighlight">\(A\)</span> sea de <em>rank</em> completo el sistema es consistente y se busca resolver el <strong>problema de optimización de mínima norma</strong> :</p>
<div class="math notranslate nohighlight">
\[\displaystyle \min_{x \in \mathcal{K}} ||x||_2\]</div>
<p>donde: <span class="math notranslate nohighlight">\(\mathcal{K} = \{x \in \mathbb{R}^n | Ax = b\}\)</span> que es interesante para <span class="math notranslate nohighlight">\(b \neq 0\)</span> y tiene única solución.</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Recuérdese que el producto <span class="math notranslate nohighlight">\(x^T Ax\)</span> con <span class="math notranslate nohighlight">\(A\)</span> simétrica se le nombra forma cuadrática y es un número en <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>.</p>
</div>
<div class="admonition-comentarios admonition">
<p class="admonition-title">Comentarios</p>
<ul class="simple">
<li><p>El problema de mínimos cuadrados es un problema convexo no importando si <span class="math notranslate nohighlight">\(A\)</span> es o no de <em>rank</em> completo pues la forma cuadrática involucra a la expresión <span class="math notranslate nohighlight">\(x^TA^TAx\)</span> y <span class="math notranslate nohighlight">\(A^TA \in \mathbb{S}^n_+\)</span>.</p></li>
<li><p>El problema de optimización a resolver para el caso de sistemas de ecuaciones lineales <em>underdetermined</em> y matriz del sistema de <em>rank</em> completo también puede escribirse como:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\min_{x \in \mathbb{R}^n} ||x||_2\]</div>
<div class="math notranslate nohighlight">
\[\text{sujeto a:} Ax = b\]</div>
<p>el cual es un problema de optimización convexa con restricciones (no importando si <span class="math notranslate nohighlight">\(A\)</span> es o no de <em>rank</em> completo).</p>
<ul class="simple">
<li><p>Que un sistema de ecuaciones lineales <em>underdetermined</em> pueda tener infinitas soluciones si <span class="math notranslate nohighlight">\(A\)</span> es de <em>rank</em> completo se sigue por el resultado del álgebra lineal <a class="reference external" href="https://en.wikipedia.org/wiki/Rank%E2%80%93nullity_theorem">Rank-nullity theorem</a>. Con las dimensiones definidas tal resultado se escribe como <span class="math notranslate nohighlight">\(n = rank(A) + nullity(A) = m + nullity(A)\)</span> <span class="math notranslate nohighlight">\(\therefore nullity(A) = n-m &gt; 0\)</span>. Si <span class="math notranslate nohighlight">\(x_0 \in \mathbb{R}^n\)</span> es una solución de <span class="math notranslate nohighlight">\(Ax=b\)</span> entonces <span class="math notranslate nohighlight">\(x_0 + N(A)\)</span> es el conjunto de soluciones de <span class="math notranslate nohighlight">\(Ax=b\)</span>, donde <span class="math notranslate nohighlight">\(x_0 + N(A) = \{x_0 + z | z \in N(A)\}\)</span>.</p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="id1">
<h2>Ecuaciones no lineales<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>El problema que queremos resolver es el siguiente: dada <span class="math notranslate nohighlight">\(f: \mathbb{R} \rightarrow \mathbb{R}\)</span> encontrar <span class="math notranslate nohighlight">\(x^*\)</span> que resuelva la ecuación no lineal <span class="math notranslate nohighlight">\(f(x) = 0\)</span>. Nos interesa al menos una solución de la ecuación anterior.</p>
<div class="admonition-definicion admonition">
<p class="admonition-title">Definición</p>
<p><span class="math notranslate nohighlight">\(x^*\)</span> se nombra raíz o cero de <span class="math notranslate nohighlight">\(f\)</span>.</p>
</div>
<p>Algunos ejemplos son:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(e^x+1=0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(e^{-x}-x =0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(x^2 -4\sin(x)=0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(x^3+6x^2+11x-6=0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\sin(x) = 0\)</span>.</p></li>
</ul>
<p><strong>Resolvamos con <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fsolve.html#scipy.optimize.fsolve">scipy.optimize.fsolve</a> algunas de las ecuaciones no lineales anteriores.</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fsolve</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>La ecuación no lineal <span class="math notranslate nohighlight">\(e^x + 1 = 0\)</span> no tiene solución, su gráfica es la siguiente</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eqn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">eqn</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;$f(x) = e^x + 1$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/Ecuaciones_no_lineales_45_0.png" src="../../_images/Ecuaciones_no_lineales_45_0.png" />
</div>
</div>
<p>La ecuación no lineal <span class="math notranslate nohighlight">\(e^{-x} - x = 0\)</span> tiene una solución</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">.25</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eqn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span>
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Elegimos un punto inicial por ejemplo el <span class="math notranslate nohighlight">\(0\)</span>.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0.567]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">eqn</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;$f(x) = e^{-x}-x$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/Ecuaciones_no_lineales_51_0.png" src="../../_images/Ecuaciones_no_lineales_51_0.png" />
</div>
</div>
<p>La ecuación no lineal <span class="math notranslate nohighlight">\(x^2 -4\sin(x)=0\)</span> tiene dos soluciones</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eqn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Elegimos un punto inicial por ejemplo el <span class="math notranslate nohighlight">\(-2\)</span>.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0.]
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Observamos que tenemos dos raíces de <span class="math notranslate nohighlight">\(f\)</span>.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">eqn</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;$f(x) = x^2-4\sin(x)$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/Ecuaciones_no_lineales_58_0.png" src="../../_images/Ecuaciones_no_lineales_58_0.png" />
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Elegimos un punto inicial por ejemplo el <span class="math notranslate nohighlight">\(3\)</span>.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">root2</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">root2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1.934]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">eqn</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">root2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;$f(x) = x^2-4\sin(x)$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/Ecuaciones_no_lineales_61_0.png" src="../../_images/Ecuaciones_no_lineales_61_0.png" />
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Como ejemplo que no es posible expresar las raíces o ceros por una fórmula cerrada que involucren a los coeficientes, operaciones aritméticas y raíces <span class="math notranslate nohighlight">\(\sqrt[n]{\cdot}\)</span>, considérese la ecuación no lineal <span class="math notranslate nohighlight">\(x^5 - x^2 + 1 = 0\)</span>.</p>
</div>
<div class="admonition-comentarios admonition">
<p class="admonition-title">Comentarios</p>
<ul class="simple">
<li><p>En el caso de una ecuación o un sistema de ecuaciones no lineales no tenemos resultados que determinen la existencia o unicidad de soluciones a diferencia de un sistema lineal. Sin embargo, en muchas situaciones en la práctica se resuelven ecuaciones no lineales que sí tienen solución y se desea aproximar una solución o varias soluciones en una región de interés por lo que determinar la existencia o unicidad de la solución no es primordial.</p></li>
<li><p>La mayoría de los métodos para calcular raíces o ceros de <span class="math notranslate nohighlight">\(f\)</span> vía la ecuación no lineal <span class="math notranslate nohighlight">\(f(x) = 0\)</span> nos devuelven aproximaciones y no fórmulas cerradas. Son métodos <strong>iterativos</strong> que en el caso de <span class="math notranslate nohighlight">\(1\)</span> dimensión los podemos dividir en <span class="math notranslate nohighlight">\(2\)</span> tipos: <strong>cerrados</strong> y <strong>abiertos</strong>. Los cerrados inician sus iteraciones en un intervalo que encierra a la raíz y conforme avanzan las iteraciones hacen subdivisiones del intervalo inicial por lo que su longitud se reduce y <strong>siempre</strong> convergen. Los abiertos no requieren encerrar a la raíz, en general tienen mejor desempeño que los cerrados en cuanto al número de iteraciones pero <strong>no siempre convergen</strong>.</p></li>
<li><p>Es conveniente comentar que si bien quisiéramos tener algoritmos que calculasen todas las raíces o ceros de <span class="math notranslate nohighlight">\(f\)</span> esto no es posible, es un hecho que los métodos nos darán una solución aproximada o un mensaje del tipo “no se encontró solución”.</p></li>
</ul>
</div>
</div>
<div class="section" id="criterios-de-paro-escala-de-la-variable-x-y-de-la-funcion-f">
<span id="critparo"></span><h2>Criterios de paro, escala de la variable <span class="math notranslate nohighlight">\(x\)</span> y de la función <span class="math notranslate nohighlight">\(f\)</span><a class="headerlink" href="#criterios-de-paro-escala-de-la-variable-x-y-de-la-funcion-f" title="Permalink to this headline">¶</a></h2>
<p>Un tema importante en la implementación de algoritmos es la escala del problema tanto en la variable <span class="math notranslate nohighlight">\(x\)</span> como en la función <span class="math notranslate nohighlight">\(f\)</span>. Por ejemplo, si <span class="math notranslate nohighlight">\(x_1\)</span> está en el rango <span class="math notranslate nohighlight">\([10^2, 10^3]\)</span> de metros y <span class="math notranslate nohighlight">\(x_2\)</span> está en el rango <span class="math notranslate nohighlight">\([10^{-7}, 10^{-6}]\)</span> de segundos entonces tenemos que realizar un reescalamiento para tener evaluaciones de <span class="math notranslate nohighlight">\(f\)</span>, criterios de paro y actualizaciones en esquemas iterativos, por ejemplo, independientes de las escalas de las variables o de la función. Asimismo, los criterios de paro en un método iterativo ayudan a contestar preguntas del tipo ¿hemos resuelto el problema de forma aproximada? ¿en las últimas dos (o un poco más) iteraciones nos hemos quedado virtualmente en el mismo punto?</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>El reescalamiento en el ejemplo de kilómetros y microsegundos puede describirse como la multiplicación de una matriz diagonal por las variables <span class="math notranslate nohighlight">\(x_1\)</span> y <span class="math notranslate nohighlight">\(x_2\)</span> en la que las entradas de la diagonal son <span class="math notranslate nohighlight">\(\frac{1}{10^3}\)</span> y <span class="math notranslate nohighlight">\(\frac{1}{10^{-6}}\)</span> para las variables <span class="math notranslate nohighlight">\(x_1\)</span> y <span class="math notranslate nohighlight">\(x_2\)</span> respectivamente.</p>
</div>
<p>Muchos algoritmos cumplen que son invariantes ante escala de las variables, el método de Newton en la variable <span class="math notranslate nohighlight">\(x\)</span> es uno de ellos por ejemplo, pero otros no, por lo que al implementar un algoritmo se debe revisar los reescalamientos a realizar. En el ejemplo anterior de los metros y segundos si se cambian las unidades de <span class="math notranslate nohighlight">\(x_1\)</span> a kilómetros y las de <span class="math notranslate nohighlight">\(x_2\)</span> a microsegundos entonces tanto <span class="math notranslate nohighlight">\(x_1\)</span> como <span class="math notranslate nohighlight">\(x_2\)</span> se encontrarán en el rango <span class="math notranslate nohighlight">\([10^{-1}, 1]\)</span>. Si en dos dimensiones <span class="math notranslate nohighlight">\(x_1 \in [10^{6}, 10^{7}]\)</span> y <span class="math notranslate nohighlight">\(x_2 \in [10^{-1}, 1]\)</span> entonces una prueba del tipo <span class="math notranslate nohighlight">\(||\nabla f(x)|| &lt;  10^{-3}\)</span> no será equilibrada para ambas variables si se desea por ejemplo minimizar <span class="math notranslate nohighlight">\(f\)</span> (<span class="math notranslate nohighlight">\(x_1\)</span> tendería a ser lo más pequeña posible si por ejemplo tenemos una alta contribución de esta variable en <span class="math notranslate nohighlight">\(f\)</span>).</p>
<p>En el caso de la función <span class="math notranslate nohighlight">\(f\)</span>, es común requerir que <span class="math notranslate nohighlight">\(f\)</span> o la magnitud de <span class="math notranslate nohighlight">\(f\)</span> sea cero (o su derivada). Si consideramos <span class="math notranslate nohighlight">\(f(x) = 0\)</span> es muy probable que los errores por redondeo no permitan que se satisfaga esto para ningún punto <span class="math notranslate nohighlight">\(x\)</span> por lo que modificamos la condición anterior a <span class="math notranslate nohighlight">\(f(x) \approx 0\)</span>. También si <span class="math notranslate nohighlight">\(f\)</span> no está escalada apropiadamente la condición <span class="math notranslate nohighlight">\(|f(x)| &lt; tol\)</span> es probable que siempre o nunca se satisfaga. Por ejemplo si <span class="math notranslate nohighlight">\(tol = 10^{-3}\)</span> y <span class="math notranslate nohighlight">\(f\)</span> siempre está en <span class="math notranslate nohighlight">\([10^{-7}, 10^{-5}]\)</span> entonces cualquier <span class="math notranslate nohighlight">\(x\)</span> satisface <span class="math notranslate nohighlight">\(|f(x)| &lt; 10^{-3}\)</span>.</p>
<p>Considerando <span class="math notranslate nohighlight">\(f: \mathbb{R}^n \rightarrow \mathbb{R}^n\)</span>, dentro de los criterios de paro que se utilizan en los métodos iterativos para resolver ecuaciones no lineales que apuntan a tener una evaluación independiente de la escala se encuentran:</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>En los criterios de paro que revisan la norma de la derivada de <span class="math notranslate nohighlight">\(f\)</span>, una opción independiente de la escala de <span class="math notranslate nohighlight">\(f\)</span> y <span class="math notranslate nohighlight">\(x\)</span> es la cantidad <span class="math notranslate nohighlight">\(\frac{||Df(x)||||x||}{||f(x)||}\)</span>.</p>
</div>
<ul class="simple">
<li><p>Medir diferencia entre iteraciones. Por ejemplo:</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(||x^{(k+1)} - x^{(k)}|| &lt; tol(||x^{(k)}|| +1)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(||x^{(k+1)} - x^{(k)}|| &lt; tol\max\{||x^{(k+1)}||, ||x^{(k)}||\}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(||x^{(k+1)} - x^{(k)}|| &lt; tol\max\{||x^{(k+1)}||, \text{user_defined_value}\}\)</span>.</p></li>
</ul>
</li>
</ul>
<p>con <code class="docutils literal notranslate"><span class="pre">user_defined_value</span></code> un valor positivo proporcionado por <em>user</em> que mide la magnitud típica de <span class="math notranslate nohighlight">\(x\)</span> y <span class="math notranslate nohighlight">\(|| \cdot ||\)</span> norma.</p>
<ul class="simple">
<li><p>Medir la norma de <span class="math notranslate nohighlight">\(f\)</span> reescalándola por ejemplo:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[||Diag f|| &lt; tol\]</div>
<p>con <span class="math notranslate nohighlight">\(Diag\)</span> matriz diagonal tal que <span class="math notranslate nohighlight">\(Diagf\)</span> tenga norma alrededor de <span class="math notranslate nohighlight">\(1\)</span> en puntos no cercanos a la raíz y también puede proveerse sus valores con un <code class="docutils literal notranslate"><span class="pre">user_defined_value</span></code>.</p>
<ul class="simple">
<li><p>Máximo número de iteraciones.</p></li>
</ul>
</div>
<div class="section" id="metodos-para-resolver-ecuaciones-no-lineales-de-funciones-f-mathbb-r-rightarrow-mathbb-r">
<h2>Métodos para resolver ecuaciones no lineales de funciones <span class="math notranslate nohighlight">\(f: \mathbb{R} \rightarrow \mathbb{R}\)</span><a class="headerlink" href="#metodos-para-resolver-ecuaciones-no-lineales-de-funciones-f-mathbb-r-rightarrow-mathbb-r" title="Permalink to this headline">¶</a></h2>
<div class="section" id="metodo-de-biseccion">
<h3>Método de bisección<a class="headerlink" href="#metodo-de-biseccion" title="Permalink to this headline">¶</a></h3>
<p>Es un método cerrado que requiere <span class="math notranslate nohighlight">\(f \in \mathbb{R} \rightarrow \mathbb{R}\)</span> con <span class="math notranslate nohighlight">\(f \in \mathcal{C}([a,b])\)</span> tal que <span class="math notranslate nohighlight">\(f(a) f(b) &lt;0\)</span>, esto es, que <span class="math notranslate nohighlight">\(f\)</span> tenga un cambio de signo. Por el <strong>teorema del valor intermedio</strong> se cumple que <span class="math notranslate nohighlight">\(f\)</span> tiene una raíz en <span class="math notranslate nohighlight">\([a,b]\)</span>.</p>
</div>
<div class="section" id="algoritmo-metodo-de-biseccion">
<h3>Algoritmo: método de bisección<a class="headerlink" href="#algoritmo-metodo-de-biseccion" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Dados</strong> <span class="math notranslate nohighlight">\(x_i, x_s\)</span> límite inferior y superior respectivamente tales que <span class="math notranslate nohighlight">\(x^* \in [x_i, x_s]\)</span> con <span class="math notranslate nohighlight">\(f(x_i)f(x_s)&lt;0\)</span> y <span class="math notranslate nohighlight">\(tol &gt;0\)</span></p>
<p><strong>Repetir</strong> el siguiente bloque para <span class="math notranslate nohighlight">\(k=1,2,\dots\)</span></p>
<blockquote>
<div><ol class="simple">
<li><p><span class="math notranslate nohighlight">\(x_m = \frac{x_i + x_s}{2}\)</span></p></li>
<li><p>Si <span class="math notranslate nohighlight">\(f(x_i)f(x_m) &lt; 0\)</span> entonces <span class="math notranslate nohighlight">\(x^* \in [x_i, x_m]\)</span> por lo tanto <span class="math notranslate nohighlight">\(x_s = x_m\)</span>.</p></li>
<li><p>Si <span class="math notranslate nohighlight">\(f(x_i)f(x_m) &gt; 0\)</span> entonces <span class="math notranslate nohighlight">\(x^* \in [x_m, x_s]\)</span> por lo tanto <span class="math notranslate nohighlight">\(x_i = x_m\)</span>.</p></li>
</ol>
</div></blockquote>
<p><strong>hasta</strong> convergencia: satisfacer criterio de paro en el que se utiliza <span class="math notranslate nohighlight">\(tol\)</span> y <span class="math notranslate nohighlight">\(maxiter\)</span>.</p>
</div></blockquote>
<div class="admonition-comentarios admonition">
<p class="admonition-title">Comentarios</p>
<p>En el método de bisección:</p>
<ul class="simple">
<li><p>Se garantiza que el error relativo en cada iteración se reduce por la mitad y se obtiene una cantidad constante de dígitos por cada iteración, lo cual es representativo de una convergencia lineal.</p></li>
<li><p>Siempre tenemos convergencia pero es lenta.</p></li>
<li><p>No es posible extenderlo a más dimensiones de forma natural pues tendríamos que definir metodologías para elegir puntos en regiones como rectángulos, cubos,… para evaluar a la función <span class="math notranslate nohighlight">\(f\)</span> y determinar cambios de signo.</p></li>
<li><p>La evaluación de los pasos 2 y 3 del algoritmo anterior se visualizan respectivamente como sigue:</p></li>
</ul>
<img src="https://dl.dropboxusercontent.com/s/sl9m30qmy8cf4rr/bisection_method.png?dl=0" heigth="600" width="600">
<p>en el dibujo <span class="math notranslate nohighlight">\(x^{(k)}\)</span> corresponde a <span class="math notranslate nohighlight">\(x_m\)</span>.</p>
<ul class="simple">
<li><p>La implementación del método utiliza lo siguiente:</p>
<ul>
<li><p>El punto medio se calcula con la expresión: <span class="math notranslate nohighlight">\(x_m = x_i + \frac{x_s - x_i}{2}\)</span></p></li>
<li><p>Se revisan los signos de <span class="math notranslate nohighlight">\(f(x_i)\)</span>, <span class="math notranslate nohighlight">\(f(x_m)\)</span> para determinar si <span class="math notranslate nohighlight">\(f(x_i)f(x_m) &lt; 0\)</span> o <span class="math notranslate nohighlight">\(f(x_i)f(x_m) &gt; 0\)</span>.</p></li>
</ul>
</li>
<li><p>El criterio de paro es de la forma:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="o">|</span><span class="n">xi</span> <span class="o">-</span> <span class="n">xs</span><span class="o">|</span> <span class="o">&gt;</span> <span class="n">tol1</span><span class="p">(</span><span class="mi">1</span><span class="o">+|</span><span class="n">xi</span><span class="o">|+|</span><span class="n">xs</span><span class="o">|</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x_m</span><span class="p">)</span><span class="o">|</span> <span class="o">&gt;</span> <span class="n">tol2</span> <span class="o">&amp;&amp;</span> <span class="n">iterations</span> <span class="o">&lt;</span> <span class="n">max_iters</span>
</pre></div>
</div>
<p>con <code class="docutils literal notranslate"><span class="pre">tol1</span></code>, <code class="docutils literal notranslate"><span class="pre">tol2</span></code> cantidades pequeñas y positivas (comúnmente menores o iguales a <span class="math notranslate nohighlight">\(10^{-8}\)</span>), <code class="docutils literal notranslate"><span class="pre">iterations</span></code> un contador de las iteraciones. En una implementación también pueden utilizarse la medición entre iteraciones con los criterios descritos en <a class="reference internal" href="#critparo"><span class="std std-ref">criterios de paro, escala de la variable x y de la función f</span></a> y si se tiene conocimiento del valor de <span class="math notranslate nohighlight">\(x^*\)</span> se pueden calcular errores relativos de <code class="docutils literal notranslate"><span class="pre">x_k</span></code>, así como los reescalamientos respectivos de <span class="math notranslate nohighlight">\(x\)</span> y <span class="math notranslate nohighlight">\(f\)</span>.</p>
</div>
<div class="tip admonition">
<p class="admonition-title">Ejercicio</p>
<p>Con el método de bisección aproxima la raíz <span class="math notranslate nohighlight">\(x^* \approx 0.56714329\)</span> de la ecuación no lineal <span class="math notranslate nohighlight">\(f(x) = e^{-x}-x\)</span> tomando como intervalo inicial <span class="math notranslate nohighlight">\([0,2]\)</span> y un valor de <span class="math notranslate nohighlight">\(tol = 10^{-8}\)</span>. Crea una tabla de la forma:</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p>Iter</p></th>
<th class="text-align:center head"><p><span class="math notranslate nohighlight">\(x_i\)</span></p></th>
<th class="text-align:center head"><p><span class="math notranslate nohighlight">\(x_s\)</span></p></th>
<th class="text-align:center head"><p><span class="math notranslate nohighlight">\(x^{(k)}\)</span></p></th>
<th class="text-align:center head"><p>Err_rel<span class="math notranslate nohighlight">\((x^{(k)})\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p>1</p></td>
<td class="text-align:center"><p>0</p></td>
<td class="text-align:center"><p>2</p></td>
<td class="text-align:center"><p>1</p></td>
<td class="text-align:center"><p>1.5 e-2</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>2</p></td>
<td class="text-align:center"><p>0</p></td>
<td class="text-align:center"><p>1</p></td>
<td class="text-align:center"><p>0.5</p></td>
<td class="text-align:center"><p>1.3 e-2</p></td>
</tr>
</tbody>
</table>
<p>(valores ejemplo)</p>
</div>
</div>
<div class="section" id="metodo-de-newton-o-newton-raphson">
<h3>Método de Newton o Newton-Raphson<a class="headerlink" href="#metodo-de-newton-o-newton-raphson" title="Permalink to this headline">¶</a></h3>
<p>Es un método abierto que sigue un esquema iterativo de la forma:</p>
<div class="math notranslate nohighlight">
\[x^{(k+1)} = x^{(k)} - \frac{f(x^{(k)})}{f'(x^{(k)})}\]</div>
<p>requiere un punto inicial <span class="math notranslate nohighlight">\(x^{(0)}\)</span> y converge si se cumplen condiciones descritas en <a class="reference internal" href="#comentmetnewtonrapshon"><span class="std std-ref">comentarios del método de Newton-Raphson</span></a>.</p>
<p>Existen varias formas de obtener tal esquema iterativo, la que se presenta a continuación <strong>define un modelo afín local que aproxima a nuestra función <span class="math notranslate nohighlight">\(f\)</span> y encuentra la raíz de tal modelo</strong>, gráficamente:</p>
<img src="https://dl.dropboxusercontent.com/s/hw6fluifowjnpdo/Newton-Raphson_method.png?dl=0" heigth="600" width="600"><p>El modelo afín en el dibujo anterior es de la forma:</p>
<div class="math notranslate nohighlight">
\[M(x) = f(x^{(k)}) + f'(x^{(k)})(x-x^{(k)})\]</div>
<p>E igualando a cero el modelo se tiene:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{eqnarray}
0 &amp;=&amp; M(x) = f(x^{(k)}) + f'(x^{(k)})(x-x^{(k)}) \nonumber \\
&amp;\therefore&amp; x = x^{(k)} - \frac{f(x^{(k)})}{f'(x^{(k)})} \nonumber
\end{eqnarray}
\end{split}\]</div>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<p>Obsérvese que el modelo afín anterior <span class="math notranslate nohighlight">\(M(x)\)</span> es la aproximación a primer orden dada por el teorema de Taylor.</p>
</div>
</div>
<div class="section" id="ejemplo">
<h3>Ejemplo<a class="headerlink" href="#ejemplo" title="Permalink to this headline">¶</a></h3>
<p>Encontrar la raíz de <span class="math notranslate nohighlight">\(f(x) = 4x + 5\)</span> con el método de Newton.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sympy</span> 
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Elección del punto inicial.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x_0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Definición de función.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">5</span>
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Derivada de <span class="math notranslate nohighlight">\(f\)</span>.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sympy</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Actualización por el método de Newton: <span class="math notranslate nohighlight">\(x_1 = x_0 - \frac{f(x_0)}{f'(x_0)}\)</span>.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x_1</span> <span class="o">=</span> <span class="n">x_0</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x_0</span><span class="p">)</span><span class="o">/</span><span class="n">df</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x_0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sympy</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">x_1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-5/4
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="algoritmo-metodo-de-newton-para-resolver-una-ecuacion-no-lineal">
<h3>Algoritmo: método de Newton para resolver una ecuación no lineal<a class="headerlink" href="#algoritmo-metodo-de-newton-para-resolver-una-ecuacion-no-lineal" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Dados</strong> <span class="math notranslate nohighlight">\(x^{(0)}\)</span> punto inicial, <span class="math notranslate nohighlight">\(f: \mathbb{R} \rightarrow \mathbb{R}\)</span> y <span class="math notranslate nohighlight">\(tol &gt;0\)</span></p>
<p><span class="math notranslate nohighlight">\(x:=x^{(0)}\)</span>.</p>
<p><strong>Repetir</strong> el siguiente bloque para <span class="math notranslate nohighlight">\(k=1,2,\dots\)</span></p>
<blockquote>
<div><ol class="simple">
<li><p>Calcular  la derivada de <span class="math notranslate nohighlight">\(f\)</span> y verificar que <span class="math notranslate nohighlight">\(f'(x) \neq 0\)</span>.</p></li>
<li><p>Realizar la actualización: <span class="math notranslate nohighlight">\(x = x - \frac{f(x)}{f'(x)}\)</span></p></li>
</ol>
</div></blockquote>
<p><strong>hasta</strong> convergencia: satisfacer criterio de paro en el que se utiliza <span class="math notranslate nohighlight">\(tol\)</span> y <span class="math notranslate nohighlight">\(maxiter\)</span>.</p>
</div></blockquote>
</div>
<div class="section" id="id2">
<h3>Ejemplo<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>Aproximar el valor <span class="math notranslate nohighlight">\(\sqrt{3}\)</span> con el método de Newton</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Elección del punto inicial. ¿Qué pasa si elegimos <span class="math notranslate nohighlight">\(x_0 = -10\)</span>?</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x_0</span> <span class="o">=</span> <span class="mi">10</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x_sym</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Definimos la función <span class="math notranslate nohighlight">\(f(x) = x^2 - 3\)</span></p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">x_sym</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span>
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Derivada de <span class="math notranslate nohighlight">\(f\)</span>.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sympy</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2⋅x
</pre></div>
</div>
</div>
</div>
<p><strong>Primera iteración</strong></p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Actualización por el método de Newton: <span class="math notranslate nohighlight">\(x_1 = x_0 - \frac{f(x_0)}{f'(x_0)}\)</span>.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">x_0</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x_sym</span><span class="p">,</span> <span class="n">x_0</span><span class="p">)</span><span class="o">/</span><span class="n">df</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x_sym</span><span class="p">,</span> <span class="n">x_0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sympy</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>103
───
 20
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sympy</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">evalf</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5.15000000000000
</pre></div>
</div>
</div>
</div>
<p><strong>Segunda iteración</strong></p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Actualización por el método de Newton: <span class="math notranslate nohighlight">\(x_2 = x_1 - \frac{f(x_1)}{f'(x_1)}\)</span>.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x_sym</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">df</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x_sym</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sympy</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>11809
─────
 4120
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sympy</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">evalf</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.86626213592233
</pre></div>
</div>
</div>
</div>
<p><strong>Tercera iteración</strong></p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Actualización por el método de Newton: <span class="math notranslate nohighlight">\(x_3 = x_2 - \frac{f(x_2)}{f'(x_2)}\)</span>.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x_sym</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">df</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x_sym</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sympy</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>190375681
─────────
 97306160
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sympy</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">evalf</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.95646073177690
</pre></div>
</div>
</div>
</div>
<p><strong>…</strong></p>
<p><strong>Séptima iteración</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x_7</span> <span class="o">=</span> <span class="mf">1.73205080756888</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytest</span> <span class="kn">import</span> <span class="n">approx</span>
<span class="kn">import</span> <span class="nn">math</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">x_7</span> <span class="o">==</span> <span class="n">approx</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="admonition-comentarios admonition" id="comentmetnewtonrapshon">
<p class="admonition-title">Comentarios</p>
<ul class="simple">
<li><p>El modelo afín anterior <span class="math notranslate nohighlight">\(M(x) = f(x^{(k)}) + f'(x^{(k)})(x-x^{(k)})\)</span> es también nombrado <strong>modelo lineal</strong>.</p></li>
<li><p>Si la función <span class="math notranslate nohighlight">\(f\)</span> es lineal el método de Newton converge en una iteración.</p></li>
<li><p>La convergencia del método de Newton en una dimensión converge de forma cuadrática, esto es, el número de dígitos de precisión en cada iteración se duplica si se satisfacen las siguientes condiciones:</p>
<ul>
<li><p>El punto inicial <span class="math notranslate nohighlight">\(x^{(0)}\)</span> es cercano a la raíz <span class="math notranslate nohighlight">\(x^*\)</span> de <span class="math notranslate nohighlight">\(f\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(f'(x^*) \neq 0\)</span> y existe un conjunto abierto <span class="math notranslate nohighlight">\(\mathcal{D}\)</span> en el que <span class="math notranslate nohighlight">\(f'(x) \neq 0\)</span> <span class="math notranslate nohighlight">\(\forall x \in \mathcal{D}\)</span>, <span class="math notranslate nohighlight">\(x^* \in \mathcal{D}\)</span> y la segunda derivada de <span class="math notranslate nohighlight">\(f\)</span> es acotada en <span class="math notranslate nohighlight">\(\mathcal{D}\)</span> *.</p></li>
</ul>
</li>
</ul>
<p>* La segunda condición referente a la segunda derivada puede ser sustituida por la condición que la primera derivada sea <em>Lipschitz</em> continua en <span class="math notranslate nohighlight">\(\mathcal{D}\)</span>, ver <a class="reference external" href="https://en.wikipedia.org/wiki/Lipschitz_continuity">Lipschitz_continuity</a>. Esto ayuda a acotar la diferencia entre <span class="math notranslate nohighlight">\(f\)</span> y el modelo afín <span class="math notranslate nohighlight">\(M\)</span>. Además evitamos calcular la segunda derivada (que en más dimensiones puede ser complicada de describir) para verificar convergencia.</p>
<ul class="simple">
<li><p>El criterio de paro es de la forma:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="o">|</span><span class="n">x_</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">x_k</span><span class="o">|</span> <span class="o">&gt;</span> <span class="n">tol1</span><span class="p">(</span><span class="o">|</span><span class="n">x_k</span><span class="o">|</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x_</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">|</span> <span class="o">&gt;</span> <span class="n">tol2</span> <span class="o">&amp;&amp;</span> <span class="n">iterations</span> <span class="o">&lt;</span> <span class="n">max_iters</span>
</pre></div>
</div>
<p>con <code class="docutils literal notranslate"><span class="pre">tol1</span></code>, <code class="docutils literal notranslate"><span class="pre">tol2</span></code> cantidades pequeñas y positivas (comúnmente menores o iguales a <span class="math notranslate nohighlight">\(10^{-8}\)</span>), <code class="docutils literal notranslate"><span class="pre">iterations</span></code> un contador de las iteraciones. En una implementación también pueden utilizarse la medición entre iteraciones con los criterios descritos en <a class="reference internal" href="#critparo"><span class="std std-ref">criterios de paro, escala de la variable x y de la función f</span></a> y si se tiene conocimiento del valor de <span class="math notranslate nohighlight">\(x^*\)</span> se pueden calcular errores relativos de <code class="docutils literal notranslate"><span class="pre">x_k</span></code>, así como los reescalamientos respectivos de <span class="math notranslate nohighlight">\(x\)</span> y <span class="math notranslate nohighlight">\(f\)</span>.</p>
<ul class="simple">
<li><p>En la implementación del método hay que monitorear el valor absoluto de la derivada de <span class="math notranslate nohighlight">\(f\)</span>.</p></li>
</ul>
</div>
<div class="tip admonition">
<p class="admonition-title">Observaciones</p>
<ul class="simple">
<li><p>Si la derivada de <span class="math notranslate nohighlight">\(f\)</span> es cero en la raíz no podemos concluir si el método de Newton converge o no y si converge podría o no hacerlo de forma cuadrática.</p></li>
<li><p>Si elegimos un punto inicial lejos de <span class="math notranslate nohighlight">\(x^*\)</span> no podemos concluir, el método de Newton podría o no converger.</p></li>
</ul>
</div>
<div class="tip admonition">
<p class="admonition-title">Ejercicio</p>
<p>Para revisar la hipótesis que la derivada de <span class="math notranslate nohighlight">\(f\)</span> sea diferente de cero en la raíz y garantice que el método de Newton tenga convergencia cuadrática considérese aproximar la raíz <span class="math notranslate nohighlight">\(1\)</span> para las ecuaciones no lineales:</p>
<p>1.<span class="math notranslate nohighlight">\(x^2-1=0\)</span></p>
<p>2.<span class="math notranslate nohighlight">\(x^2-2x+1=0\)</span></p>
<p>Realícense <span class="math notranslate nohighlight">\(6\)</span> iteraciones del método de Newton para cada ecuación no lineal y háganse conclusiones.</p>
</div>
<div class="tip admonition">
<p class="admonition-title">Ejercicio</p>
<p>Para revisar la hipótesis que el punto inicial <span class="math notranslate nohighlight">\(x^{(0)}\)</span> sea “cercano” a la raíz y garantice que el método de Newton tenga convergencia cuadrática considérese aproximar la raíz <span class="math notranslate nohighlight">\(0\)</span> para la ecuación no lineal <span class="math notranslate nohighlight">\(\arctan(x) = 0\)</span>. Realícense <span class="math notranslate nohighlight">\(6\)</span> iteraciones del método de Newton eligiendo un punto <span class="math notranslate nohighlight">\(x^{(0)}\)</span> en tres casos:</p>
<p>1.tal que sea en valor absoluto menor a un punto cualquiera en <span class="math notranslate nohighlight">\([1.39, 1.40]\)</span>,</p>
<p>2.tal que esté en <span class="math notranslate nohighlight">\([1.39, 1.40]\)</span>,</p>
<p>3.tal que en valor absoluto sea mayor a un punto en el intervalo <span class="math notranslate nohighlight">\([1.39, 1.40]\)</span>.</p>
<p>y háganse conclusiones.</p>
</div>
<p>Concerniente a la dependencia de un punto inicial, la convergencia del método de Newton se robustece al incorporar metodologías que permiten su convergencia a una solución <strong>local</strong> desde prácticamente cualquier punto inicial. Tales metodologías resultan en <strong>algoritmos híbridos</strong> en los que se utiliza el método de Newton siempre que funcione bien pero se utiliza otro método (quizás más lento) que garantice convergencia. Uno de éstos es el método de bisección en el que una vez se encuentre “cerca” de una solución se utilice el método de Newton. Otra metodología consiste en lo siguiente: dado que la actualización del método de Newton involucra una dirección en la que el valor absoluto de <span class="math notranslate nohighlight">\(f(x)\)</span> <strong>siempre decrece</strong> (al menos en un inicio) entonces se utiliza una forma de <em>backtracking</em> si la actualización completa no produce una reducción en <span class="math notranslate nohighlight">\(|f(x)|\)</span>:</p>
<img src="https://dl.dropboxusercontent.com/s/nllicf8q3xqtew0/quasi_newton_hybrid_method_example.png?dl=0" heigth="400" width="400"><p>Y se realizaría lo siguiente:</p>
<div class="math notranslate nohighlight">
\[x = x^{(k)} - \frac{f(x^{(k)})}{f'(x^{(k)})}\]</div>
<p>Mientras <span class="math notranslate nohighlight">\(|f(x)| \geq |f(x^{(k)})|\)</span> realizar:</p>
<div class="math notranslate nohighlight">
\[x = \frac{x + x^{(k)}}{2}\]</div>
<p>ver por ejemplo el <a class="reference internal" href="../3.2/Algoritmos_de_descenso_y_busqueda_de_linea_en_uco.html#mbuslinback"><span class="std std-ref">método de búsqueda de línea por backtracking</span></a> en el contexto de minimización de una función.</p>
<p>El siguiente es un algoritmo en una forma general de algoritmos híbridos <a class="reference external" href="https://en.wikipedia.org/wiki/Quasi-Newton_method"><em>quasi-Newton</em></a> para resolver una ecuación no lineal.</p>
</div>
<div class="section" id="algoritmo-metodo-general-cuasi-newton-hibrido-para-resolver-una-ecuacion-no-lineal">
<span id="algmgcnhen"></span><h3>Algoritmo: método general cuasi-Newton híbrido para resolver una ecuación no lineal<a class="headerlink" href="#algoritmo-metodo-general-cuasi-newton-hibrido-para-resolver-una-ecuacion-no-lineal" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Dados</strong> <span class="math notranslate nohighlight">\(x^{(0)}\)</span> punto inicial, <span class="math notranslate nohighlight">\(f: \mathbb{R} \rightarrow \mathbb{R}\)</span> y <span class="math notranslate nohighlight">\(tol &gt;0\)</span></p>
<p><strong>Repetir</strong> el siguiente bloque para <span class="math notranslate nohighlight">\(k=1,2,\dots\)</span></p>
<blockquote>
<div><ol class="simple">
<li><p>Construir un modelo local de <span class="math notranslate nohighlight">\(f\)</span> alrededor de <span class="math notranslate nohighlight">\(x^{(k)}\)</span> y encontrar el punto <span class="math notranslate nohighlight">\(x_N\)</span> que resuelva (o cercanamente resuelva) el modelo del problema.</p></li>
<li><p>Realizar alguno de los dos pasos siguientes:</p></li>
</ol>
<blockquote>
<div><p>a. Decidir si <span class="math notranslate nohighlight">\(x^{(k+1)} = x_N\)</span> si no,</p>
<p>b. Elegir <span class="math notranslate nohighlight">\(x^{(k+1)}\)</span> usando una estrategia global (usar <span class="math notranslate nohighlight">\(x_N\)</span> del inciso a. de forma más conservadora).</p>
</div></blockquote>
</div></blockquote>
<p><strong>hasta</strong> convergencia: satisfacer criterio de paro en el que se utiliza <span class="math notranslate nohighlight">\(tol\)</span> y <span class="math notranslate nohighlight">\(maxiter\)</span>.</p>
</div></blockquote>
<p>donde: <span class="math notranslate nohighlight">\(x_N\)</span> es la actualización por el método de Newton en su esquema iterativo.</p>
<div class="admonition-comentario admonition">
<p class="admonition-title">Comentario</p>
<p>Además de estrategias globales es común que no se tengan disponibles las derivadas de <span class="math notranslate nohighlight">\(f\)</span>, en este caso las metodologías de diferenciación finita son útiles, ver <a class="reference internal" href="../../1.computo_cientifico/1.6/Polinomios_de_Taylor_y_diferenciacion_numerica.html#difnumdiffinitas"><span class="std std-ref">diferenciación numérica por diferencias finitas</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="una-nota-sobre-problemas-unconstrained-optimization-uo">
<h2>Una nota sobre problemas <em>Unconstrained Optimization</em> (UO)<a class="headerlink" href="#una-nota-sobre-problemas-unconstrained-optimization-uo" title="Permalink to this headline">¶</a></h2>
<p>En esta sección utilizamos la notación para un problema de optimización sin restricciones de la forma:</p>
<div class="math notranslate nohighlight">
\[\displaystyle \min_{x^\in \mathbb{R}^n} f_o(x)\]</div>
<p>y <span class="math notranslate nohighlight">\(f_o: \mathbb{R} \rightarrow \mathbb{R}\)</span> es una función objetivo en general que asumimos es de clase <span class="math notranslate nohighlight">\(\mathcal{C}^2\)</span> en su dominio.</p>
<p>Así como en ecuaciones no lineales no tenemos resultados que determinen la existencia o unicidad de soluciones, en problemas de optimización sin restricciones esto es similar al plantear la búsqueda de mínimos globales de las funciones objetivo. Lo mejor que podemos obtener son aproximaciones a minimos locales y es prácticamente imposible saber si se ha aproximado un mínimo global.</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Por condición necesaria de primer orden recuérdese que si <span class="math notranslate nohighlight">\(x^*\)</span> es óptimo entonces <span class="math notranslate nohighlight">\(\nabla f_o(x^*) = 0\)</span> que establece un sistema de ecuaciones no lineales en general.</p>
</div>
<p>Además, en la nota de <a class="reference internal" href="../3.2/Algoritmos_de_descenso_y_busqueda_de_linea_en_uco.html#adbluco"><span class="std std-ref">algoritmos de descenso y búsqueda de línea en Unconstrained Convex Optimization (UCO)</span></a> se mostró la relación que existe entre resolver problemas tipo UO y ecuaciones no lineales. Es natural entonces aplicar el algoritmo de <a class="reference internal" href="#algmgcnhen"><span class="std std-ref">método general cuasi-Newton híbrido para resolver una ecuación no lineal</span></a> a la ecuación no lineal de una variable <span class="math notranslate nohighlight">\(f_o'(x) = 0\)</span>. El esquema iterativo entonces es de la forma:</p>
<div class="math notranslate nohighlight">
\[x^{(k+1)} = x^{(k)} - \frac{f_o'(x^{(k)})}{f_o''(x^{(k)})}\]</div>
<p>Recuérdese que tal esquema iterativo se obtiene mediante un modelo afín de <span class="math notranslate nohighlight">\(f_o'(x)\)</span> alrededor de <span class="math notranslate nohighlight">\(x^{(k)}\)</span>, lo cual es equivalente en términos de la función <span class="math notranslate nohighlight">\(f_o\)</span> a definir un modelo cuadrático alrededor de <span class="math notranslate nohighlight">\(x^{(k)}\)</span> que aproxime a nuestra función <span class="math notranslate nohighlight">\(f_o\)</span> y que encuentre la raíz de tal modelo:</p>
<div class="math notranslate nohighlight">
\[m(x) = f_o(x^{(k)}) + f_o'(x^{(k)})(x-x^{(k)}) + \frac{1}{2} f_o''(x^{(k)})(x-x^{(k)})^2,\]</div>
<p>con lo que obtendremos el esquema iterativo anterior.</p>
<div class="admonition-comentarios admonition">
<p class="admonition-title">Comentarios</p>
<ul class="simple">
<li><p>Un modelo cuadrático es más apropiado que un modelo afín para <span class="math notranslate nohighlight">\(f_o\)</span> ya sea para maximización o minimización pues tiene a lo más un punto extremo.</p></li>
<li><p>Si la función <span class="math notranslate nohighlight">\(f_o\)</span> es una función cuadrática el método de Newton converge en una iteración.</p></li>
<li><p>Así como se revisaron las condiciones bajo las cuales el método de Newton converge de forma cuadrática, en el caso de un problema UO se requiere:</p>
<ul>
<li><p>El punto inicial <span class="math notranslate nohighlight">\(x^{(0)}\)</span> sea cercano a la raíz <span class="math notranslate nohighlight">\(x^*\)</span> de <span class="math notranslate nohighlight">\(f'\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(f''(x^*) \neq 0\)</span> y existe un conjunto abierto <span class="math notranslate nohighlight">\(\mathcal{D}\)</span> en el que <span class="math notranslate nohighlight">\(f''(x) \neq 0\)</span> <span class="math notranslate nohighlight">\(\forall x \in \mathcal{D}\)</span>, <span class="math notranslate nohighlight">\(x^* \in \mathcal{D}\)</span> y la segunda derivada sea <em>Lipschitz</em> continua en <span class="math notranslate nohighlight">\(\mathcal{D}\)</span>, ver <a class="reference external" href="https://en.wikipedia.org/wiki/Lipschitz_continuity">Lipschitz_continuity</a>. Esto ayuda a acotar la diferencia entre <span class="math notranslate nohighlight">\(f\)</span> y el modelo cuadrático <span class="math notranslate nohighlight">\(m\)</span>. Además evitamos calcular la tercera derivada (que en más dimensiones puede ser complicada de describir) para verificar convergencia.</p></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="sistema-de-ecuaciones-no-lineales">
<span id="sistecnolineales"></span><h2>Sistema de ecuaciones no lineales<a class="headerlink" href="#sistema-de-ecuaciones-no-lineales" title="Permalink to this headline">¶</a></h2>
<p>El caso de sistema de ecuaciones no lineales es una generalización del caso de una dimensión en el que tenemos <span class="math notranslate nohighlight">\(f: \mathbb{R}^n \rightarrow \mathbb{R}^n\)</span> y debemos encontrar una raíz o cero de <span class="math notranslate nohighlight">\(f\)</span> que resuelva el sistema de ecuaciones no lineales <span class="math notranslate nohighlight">\(f(x) = 0\)</span>.</p>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<p><span class="math notranslate nohighlight">\(f\)</span> tiene <span class="math notranslate nohighlight">\(n\)</span> funciones componentes:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
f(x) = \left [ \begin{array}{c}
f_1(x) \\
f_2(x) \\
\vdots \\
f_n(x)
\end{array}
\right ]
\end{split}\]</div>
<p>y su derivada es la matriz de <span class="math notranslate nohighlight">\(n \times n\)</span>, la Jacobiana <span class="math notranslate nohighlight">\((J(x))_{ij} = \frac{\partial f_i(x)}{\partial x_j}\)</span>, ver <a class="reference internal" href="../../1.computo_cientifico/1.5/Definicion_de_funcion_continuidad_derivada.html#fcd"><span class="std std-ref">Definición de función, continuidad y derivada</span></a>.</p>
</div>
<p>Algunos ejemplos son:</p>
<ol>
<li><div class="math notranslate nohighlight">
\[\begin{split}
\begin{eqnarray}
x_1^2+x_1x_2&amp;=&amp;10 \nonumber \\
x_2 + 3x_1x_2^2&amp;=&amp;57 \nonumber 
\end{eqnarray}
\end{split}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[\begin{split}
\begin{eqnarray}
2=\displaystyle \int_{-1}^{1}1dx &amp;=&amp; w_0 \cdot 1 + w_1\cdot1 \nonumber \\
0 = \displaystyle \int_{-1}^1xdx &amp;=&amp; w_0x_0 + w_1x_1 \nonumber \\
\frac{2}{3} = \displaystyle \int_{-1}^1x^2dx &amp;=&amp; w_0x_0^2 + w_1x_1^2 \nonumber \\
0 = \displaystyle \int_{-1}^1x^3dx &amp;=&amp; w_0x_0^3 + w_1x_1^3 \nonumber \\
\end{eqnarray}
\end{split}\]</div>
</li>
</ol>
</div>
<div class="section" id="metodo-de-newton-para-ecuaciones-no-lineales-de-funciones-f-mathbb-r-n-rightarrow-mathbb-r-n">
<h2>Método de Newton para ecuaciones no lineales de funciones <span class="math notranslate nohighlight">\(f: \mathbb{R}^n \rightarrow \mathbb{R}^n\)</span><a class="headerlink" href="#metodo-de-newton-para-ecuaciones-no-lineales-de-funciones-f-mathbb-r-n-rightarrow-mathbb-r-n" title="Permalink to this headline">¶</a></h2>
<p>El problema que queremos resolver es el siguiente: dada <span class="math notranslate nohighlight">\(f: \mathbb{R}^n \rightarrow \mathbb{R}^n\)</span> encontrar <span class="math notranslate nohighlight">\(x^* \in \mathbb{R}^n\)</span> que resuelva la ecuación no lineal <span class="math notranslate nohighlight">\(f(x) = 0\)</span>. Nos interesa al menos una solución de la ecuación anterior. En este problema se <strong>asume</strong> que <span class="math notranslate nohighlight">\(f \in \mathcal{C}^1\)</span> en su dominio.</p>
<p>Así como el caso de una dimensión se <strong>define un modelo afín local que aproxima a nuestra función <span class="math notranslate nohighlight">\(f\)</span> y encuentra la raíz de tal modelo</strong>. El modelo afín es:</p>
<div class="math notranslate nohighlight">
\[M(x) = f(x^{(k)}) + J(x^{(k)})(x-x^{(k)}).\]</div>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<p>Obsérvese que el modelo afín anterior <span class="math notranslate nohighlight">\(M(x)\)</span> es la aproximación a primer orden dada por el teorema de Taylor.</p>
</div>
<p>Es común reescribir tal modelo como:</p>
<div class="math notranslate nohighlight">
\[M(x + v) = f(x) + J(x)v\]</div>
<p>usando <span class="math notranslate nohighlight">\(x = x^{(k)} + v\)</span>.</p>
<p>La raíz del modelo anterior (igualándolo a cero) conduce a resolver el <strong>sistema de ecuaciones lineales</strong> siguiente:</p>
<div class="math notranslate nohighlight">
\[J(x)v = -f(x)\]</div>
<p>y por tanto el esquema iterativo por el método de Newton es:</p>
<div class="math notranslate nohighlight">
\[x = x^{(k)} + v.\]</div>
<div class="section" id="algoritmo-metodo-de-newton-multidimensional-para-resolver-un-sistema-de-ecuaciones-no-lineales">
<h3>Algoritmo: método de Newton multidimensional para resolver un sistema de ecuaciones no lineales<a class="headerlink" href="#algoritmo-metodo-de-newton-multidimensional-para-resolver-un-sistema-de-ecuaciones-no-lineales" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Dados</strong> <span class="math notranslate nohighlight">\(x^{(0)}\)</span> punto inicial, <span class="math notranslate nohighlight">\(f: \mathbb{R}^n \rightarrow \mathbb{R}^n\)</span> y <span class="math notranslate nohighlight">\(tol &gt;0\)</span>.</p>
<p><span class="math notranslate nohighlight">\(x:=x^{(0)}\)</span>.</p>
<p><strong>Repetir</strong> el siguiente bloque para <span class="math notranslate nohighlight">\(k=1,2,\dots\)</span></p>
<blockquote>
<div><ol class="simple">
<li><p>Resolver el sistema de ecuaciones lineales <span class="math notranslate nohighlight">\(J(x) v = -f(x)\)</span></p></li>
<li><p>Actualizar: <span class="math notranslate nohighlight">\(x = x + v\)</span></p></li>
</ol>
</div></blockquote>
<p><strong>hasta</strong> convergencia: satisfacer criterio de paro en el que se utiliza <span class="math notranslate nohighlight">\(tol\)</span> y <span class="math notranslate nohighlight">\(maxiter\)</span>.</p>
</div></blockquote>
</div>
<div class="section" id="id3">
<h3>Ejemplo<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>Realizar tres iteraciones del método de Newton multidimensional para resolver el siguiente sistema de ecuaciones no lineales:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{eqnarray}
x_1^2+x_1x_2 = 10 \nonumber \\
x_2 + 3x_1x_2^2 = 57 \nonumber
\end{eqnarray}
\end{split}\]</div>
<p>tomando como punto inicial: <span class="math notranslate nohighlight">\(x^{(0)} = \left [ \begin{array}{c} 1.5 \nonumber \\ 3.5 \end{array} \right ]\)</span>. La solución es <span class="math notranslate nohighlight">\(x^* = \left [ \begin{array}{c} 2 \nonumber \\ 3 \end{array} \right ]\)</span>.</p>
<p>Definimos la función <span class="math notranslate nohighlight">\(f: \mathbb{R}^2 \rightarrow \mathbb{R}^2\)</span> por:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
f(x) = 
\left [
\begin{eqnarray}
x_1^2+x_1x_2 - 10 \nonumber \\
x_2 + 3x_1x_2^2-57 \nonumber 
\end{eqnarray}
\right ]
\end{split}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;x1, x2&quot;</span><span class="p">)</span>
<span class="n">x_sym</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Definimos las componentes de <span class="math notranslate nohighlight">\(f\)</span>: <span class="math notranslate nohighlight">\(f_1(x) = x_1^2 + x_1x_2 - 10\)</span> y <span class="math notranslate nohighlight">\(f_2(x) = x_2 + 3x_1x_2^2 -57\)</span>.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f1</span> <span class="o">=</span> <span class="n">x1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x1</span><span class="o">*</span><span class="n">x2</span> <span class="o">-</span> <span class="mi">10</span>
<span class="n">f2</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">x1</span><span class="o">*</span><span class="n">x2</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">57</span>
<span class="n">f_sympy</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Esta es la función <span class="math notranslate nohighlight">\(f\)</span> a la que le deseamos aproximar la raíz dada en el ejemplo.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sympy</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">f_sympy</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>⎡   2              ⎤
⎢ x₁  + x₁⋅x₂ - 10 ⎥
⎢                  ⎥
⎢       2          ⎥
⎣3⋅x₁⋅x₂  + x₂ - 57⎦
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Elección del punto inicial <span class="math notranslate nohighlight">\(x^{(0)} = \left [ \begin{array}{c} 1.5 \nonumber \\ 3.5 \end{array} \right ]\)</span>.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f_sympy</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_sym</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Jf</span> <span class="o">=</span> <span class="n">f_sympy</span><span class="o">.</span><span class="n">jacobian</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Calculamos la Jacobiana de <span class="math notranslate nohighlight">\(f\)</span>.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Jf_eval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">partial_derivative</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="s2">&quot;x1&quot;</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                                       <span class="s2">&quot;x2&quot;</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span> <span class="k">for</span> <span class="n">partial_derivative</span> <span class="ow">in</span> <span class="n">Jf</span><span class="p">],</span>
                              <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Evaluamos la Jacobiana de <span class="math notranslate nohighlight">\(f\)</span> en el punto inicial.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">Jf_eval</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 6.5   1.5 ]
 [36.75 32.5 ]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f_eval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">component</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="s2">&quot;x1&quot;</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                             <span class="s2">&quot;x2&quot;</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">f_sympy</span><span class="p">],</span>
                            <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Evaluamos <span class="math notranslate nohighlight">\(f\)</span> en el punto inicial.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">f_eval</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[-2.5    1.625]
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Para la actualización del método de Newton multidimensional resolvemos el sistema de ecuaciones lineales: <span class="math notranslate nohighlight">\(J(x^{(0)}) v = -f(x^{(0)})\)</span></p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Jf_eval</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">-</span><span class="n">f_eval</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">v</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([ 0.536, -0.656])
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Actualización por el método de Newton: <span class="math notranslate nohighlight">\(x^{(1)} = x^{(0)} + v\)</span>.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">v</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[2.036 2.844]
</pre></div>
</div>
</div>
</div>
<p><strong>Segunda iteración</strong></p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Para la actualización del método de Newton multidimensional resolvemos el sistema de ecuaciones lineales: <span class="math notranslate nohighlight">\(J(x^{(1)}) v = -f(x^{(1)})\)</span></p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Jf_eval</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">-</span><span class="n">f_eval</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">v</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([-0.037,  0.158])
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Actualización por el método de Newton: <span class="math notranslate nohighlight">\(x^{(2)} = x^{(1)} + v\)</span>.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">v</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1.999 3.002]
</pre></div>
</div>
</div>
</div>
<p><strong>Tercera iteración</strong></p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Para la actualización del método de Newton multidimensional resolvemos el sistema de ecuaciones lineales: <span class="math notranslate nohighlight">\(J(x^{(2)}) v = -f(x^{(2)})\)</span></p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Jf_eval</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">-</span><span class="n">f_eval</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">v</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([ 0.001, -0.002])
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Actualización por el método de Newton: <span class="math notranslate nohighlight">\(x^{(3)} = x^{(2)} + v\)</span>.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">v</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[2. 3.]
</pre></div>
</div>
</div>
</div>
<div class="admonition-comentarios admonition">
<p class="admonition-title">Comentarios</p>
<ul class="simple">
<li><p>Si <span class="math notranslate nohighlight">\(x^{(0)}\)</span> es cercano a la raíz <span class="math notranslate nohighlight">\(x^*\)</span> de <span class="math notranslate nohighlight">\(f\)</span>, <span class="math notranslate nohighlight">\(J(x^*)\)</span> es no singular, no es mal condicionada y <span class="math notranslate nohighlight">\(J\)</span> es Lipschitz continua en una vecindad alrededor de <span class="math notranslate nohighlight">\(x^*\)</span> entonces el método de Newton multidimensional converge de forma cuadrática a <span class="math notranslate nohighlight">\(x^*\)</span>.</p></li>
<li><p>Al igual que en el caso de una dimensión, el criterio de paro es de la forma:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="o">||</span><span class="n">x_</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">x_k</span><span class="o">||</span> <span class="o">&gt;</span> <span class="n">tol1</span><span class="p">(</span><span class="o">||</span><span class="n">x_k</span><span class="o">||</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">||</span><span class="n">f</span><span class="p">(</span><span class="n">x_</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">||</span> <span class="o">&gt;</span> <span class="n">tol2</span> <span class="o">&amp;&amp;</span> <span class="n">iterations</span> <span class="o">&lt;</span> <span class="n">max_iters</span>
</pre></div>
</div>
<p>con <code class="docutils literal notranslate"><span class="pre">tol1</span></code>, <code class="docutils literal notranslate"><span class="pre">tol2</span></code> cantidades pequeñas y positivas (comúnmente menores o iguales a <span class="math notranslate nohighlight">\(10^{-8}\)</span>), <code class="docutils literal notranslate"><span class="pre">iterations</span></code> un contador de las iteraciones. En una implementación también pueden utilizarse la medición entre iteraciones con los criterios descritos en <a class="reference internal" href="#critparo"><span class="std std-ref">criterios de paro, escala de la variable x y de la función f</span></a> y si se tiene conocimiento del valor de <span class="math notranslate nohighlight">\(x^*\)</span> se pueden calcular errores relativos de <code class="docutils literal notranslate"><span class="pre">x_k</span></code>, así como los reescalamientos respectivos de <span class="math notranslate nohighlight">\(x\)</span> y <span class="math notranslate nohighlight">\(f\)</span>.</p>
<ul class="simple">
<li><p>En la implementación del método hay que monitorear el número de condición de la Jacobiana de <span class="math notranslate nohighlight">\(f\)</span>.</p></li>
</ul>
</div>
<div class="tip admonition">
<p class="admonition-title">Ejercicio</p>
<p>Aproximar con el método de Newton la solución <span class="math notranslate nohighlight">\(x^{*} = \left [ \begin{array}{c} 1 \nonumber \\ 1 \nonumber \\ -\sqrt{\frac{1}{3}} \nonumber \\ \sqrt{\frac{1}{3}}\end{array} \right ]\)</span> del sistema de ecuaciones no lineales con incógnitas <span class="math notranslate nohighlight">\(w_0, w_1, x_0, x_1\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{eqnarray}
2=\displaystyle \int_{-1}^{1}1dx &amp;=&amp; w_0 \cdot 1 + w_1\cdot1 \nonumber \\
0 = \displaystyle \int_{-1}^1xdx &amp;=&amp; w_0x_0 + w_1x_1 \nonumber \\
\frac{2}{3} = \displaystyle \int_{-1}^1x^2dx &amp;=&amp; w_0x_0^2 + w_1x_1^2 \nonumber \\
0 = \displaystyle \int_{-1}^1x^3dx &amp;=&amp; w_0x_0^3 + w_1x_1^3 \nonumber \\
\end{eqnarray}
\end{split}\]</div>
<p>utilizando el punto inicial: <span class="math notranslate nohighlight">\(x^{(0)} = \left [ \begin{array}{c} -1 \nonumber \\ -1 \nonumber \\ -1 \nonumber \\ 1 \end{array} \right ]\)</span>.</p>
</div>
</div>
<div class="section" id="ejemplo-componentes-principales">
<h3>Ejemplo: componentes principales<a class="headerlink" href="#ejemplo-componentes-principales" title="Permalink to this headline">¶</a></h3>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>El factor <span class="math notranslate nohighlight">\(\frac{1}{2}\)</span> se añade para que se anule la constante <span class="math notranslate nohighlight">\(2\)</span> al derivar y es equivalente la solución de este problema sin tal factor.</p>
</div>
<p>El problema de optimización:</p>
<div class="math notranslate nohighlight">
\[\displaystyle \max_{v \in \mathbb{R}^n - \{0\}} \frac{1}{2} v^TX^TXv\]</div>
<div class="math notranslate nohighlight">
\[\text{sujeto a: } \frac{1}{2}v^Tv = \frac{1}{2}\]</div>
<p>donde: <span class="math notranslate nohighlight">\(X \in \mathbb{R}^{m \times n}\)</span> y la variable de optimización es <span class="math notranslate nohighlight">\(v\)</span>. Es un problema <strong>no convexo</strong> por la restricción cuadrática de igualdad. Tiene solución cerrada dada por: <span class="math notranslate nohighlight">\(\sigma_1^2 = \sigma^2_{\text{max}}(X)\)</span>, esto es, el cuadrado del máximo valor singular de <span class="math notranslate nohighlight">\(X\)</span>.</p>
<p>Escribiendo la función Lagrangiana se tiene:</p>
<div class="math notranslate nohighlight">
\[\mathcal{L}(v, \nu) = f_o(v) + \nu h(v) = \frac{1}{2} v^T X^T X v + \frac{\nu}{2}\left(1- v^Tv\right)\]</div>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<p>Es equivalente considerar la restricción <span class="math notranslate nohighlight">\(h(v)\)</span> como <span class="math notranslate nohighlight">\(1-v^Tv\)</span> o <span class="math notranslate nohighlight">\(v^Tv-1\)</span>, ver <a class="reference internal" href="../3.3/Ejemplos_problemas_UCO_e_intro_CIEO_y_PI.html#ej1introcieo"><span class="std std-ref">ejemplo 1 en introducción a problemas CIEO</span></a> en el sentido que se obtiene la misma solución al problema de optimización.</p>
</div>
<p>Por tanto, las condiciones de <a class="reference external" href="https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions">Karush-Kuhn-Tucker</a> (KKT) de optimalidad conducen a resolver el siguiente <strong>sistema de ecuaciones no lineales</strong>:</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Ver <a class="reference internal" href="../3.3/Ejemplos_problemas_UCO_e_intro_CIEO_y_PI.html#primeraformulacioncondkkt"><span class="std std-ref">comentario relacionado con las condiciones KKT de optimalidad</span></a>. Recuérdese son:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray}
\nabla_x\mathcal{L}(x^*, \nu^*, \lambda^*) &amp;=&amp; 0 \nonumber \\
h_i(x^*) &amp;=&amp; 0 \quad \forall i = 1, \dots, p \nonumber \\
f_i(x^*) &amp;\leq&amp; 0 \quad \forall i = 1, \dots, m \nonumber \\
\lambda_i^* &amp;\geq&amp; 0 \quad \forall i = 1, \dots, m \nonumber \\
\lambda_i^* f_i(x^*) &amp;=&amp; 0 \quad \forall i = 1, \dots, m
\end{eqnarray}
\end{split}\]</div>
</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray}
\nabla_v \mathcal{L}(v, \nu) &amp;=&amp; X^TX v - \nu v=0 \nonumber \\
h(v) &amp;=&amp; \frac{1}{2}(1-v^Tv) = 0
\end{eqnarray}
\end{split}\]</div>
<p>O equivalentemente encontrar la raíz de <span class="math notranslate nohighlight">\(f: \mathbb{R}^{n+1} \rightarrow \mathbb{R}^{n+1}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}f(v, \nu) = 
\left [
\begin{array}{c}
X^TX v - \nu v \\
1-v^Tv
\end{array}
\right] = 0
\end{split}\]</div>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<p>Obsérvese que la raíz involucra al vector <span class="math notranslate nohighlight">\((v, \lambda) \in \mathbb{R}^{n+1}\)</span>.</p>
</div>
<div class="admonition-comentarios admonition">
<p class="admonition-title">Comentarios</p>
<ul class="simple">
<li><p>Resolver el problema de <strong>optimización numérica</strong> en el contexto de componentes principales:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\displaystyle \max_{v \in \mathbb{R}^n - \{0\}} v^TX^TXv\]</div>
<div class="math notranslate nohighlight">
\[\text{sujeto a:}\]</div>
<div class="math notranslate nohighlight">
\[v^Tv = 1\]</div>
<p>es equivalente a calcular el vector con máxima varianza muestral y se cumple: <span class="math notranslate nohighlight">\(v_1 = \text{argmax}_{v \in \mathbb{R}^n - \{0\}} v^TX^TXv\)</span> sujeto a: <span class="math notranslate nohighlight">\(v^Tv=1\)</span> donde <span class="math notranslate nohighlight">\(v_1\)</span> es la primera columna de <span class="math notranslate nohighlight">\(V\)</span> en la descomposición en valores singulares. Ver <a class="reference internal" href="../../2.computo_matricial/2.4/Valores_vectores_singulares_y_algoritmos_para_calcular_la_SVD.html#valvecsingalgsvd"><span class="std std-ref">Valores, vectores singulares y algoritmos para calcular la SVD</span></a>.</p>
<ul class="simple">
<li><p>La segunda componente principal <span class="math notranslate nohighlight">\(z_2\)</span> es aquella que tiene la máxima varianza muestral entre todas las combinaciones lineales de las columnas de <span class="math notranslate nohighlight">\(X\)</span> y que es <strong>ortogonal</strong>, o equivalentemente que tenga covarianza igual a cero, con <span class="math notranslate nohighlight">\(z_1\)</span>. Este problema se escribe como:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\displaystyle \max_{v \in \mathbb{R}^n - \{0\}} v^TX^TXv\]</div>
<div class="math notranslate nohighlight">
\[\text{sujeto a:}\]</div>
<div class="math notranslate nohighlight">
\[v^Tv = 1\]</div>
<div class="math notranslate nohighlight">
\[v^Tv_1 =0\]</div>
<p>con <span class="math notranslate nohighlight">\(v_1\)</span> la primera dirección principal de <span class="math notranslate nohighlight">\(X\)</span>. La solución al problema anterior está dada por: <span class="math notranslate nohighlight">\(\sigma_2^2 = \displaystyle \max_{v \in \mathbb{R}^n - \{0\}} v^TX^TXv\)</span> sujeto a: <span class="math notranslate nohighlight">\(v^Tv=1\)</span>, <span class="math notranslate nohighlight">\(v_2 = \text{argmax}_{v \in \mathbb{R}^n - \{0\}} v^TX^TXv\)</span> sujeto a: <span class="math notranslate nohighlight">\(v^Tv=1\)</span> (segunda columna de <span class="math notranslate nohighlight">\(V\)</span>).</p>
</div>
<div class="tip admonition">
<p class="admonition-title">Ejercicios</p>
<p>1.Resuelve los ejercicios y preguntas de la nota.</p>
</div>
<p><strong>Preguntas de comprehensión.</strong></p>
<p>1)Escribe las categorías en las que se pueden clasificar los sistemas de ecuaciones lineales.</p>
<p>2)¿Qué es un método iterativo abierto y qué es uno cerrado? ¿qué diferencias tienen?</p>
<p>3)¿Por qué es indispensable establecer criterios de paro que sean independientes de la escala de los datos?</p>
<p>4)¿Por qué se elige un modelo cuadrático y no un modelo afín para resolver un problema de optimización con el método de Newton?</p>
<p>5)Si queremos utilizar el método de Newton para calcular la raíz de una función <span class="math notranslate nohighlight">\(f: \mathbb{R}^n \rightarrow \mathbb{R}^n\)</span> ¿qué tenemos que calcular en una iteración cualquiera?</p>
<p>6)Escribe una relación que existe entre encontrar raíces de ecuaciones no lineales y resolver problemas de optimización.</p>
<p><strong>Referencias:</strong></p>
<ol class="simple">
<li><p>C. Meyer, Matrix Analysis and Applied Linear Algebra, SIAM, 2000.</p></li>
<li><p>J. Dennis, R. B. Schnabel, Numerical Methods for Unconstrained Optimization and Nonlinear Equations, SIAM, 1996.</p></li>
<li><p>R. Johansson, Numerical Python, Scientific Computing and Data Science Applications with Numpy, SciPy and Matplotlib, Apress, 2015.</p></li>
</ol>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "palmoreck/dockerfiles-for-binder",
            ref: "jupyterlab_optimizacion_2",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./3.optimizacion_convexa/3.4"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="../3.3/Ejemplos_problemas_UCO_e_intro_CIEO_y_PI.html" title="previous page">3.3 Ejemplos de problemas UCO, introducción a <em>Constrained Inequality and Equality Optimization</em> (CIEO) y puntos interiores</a>
    <a class='right-next' id="next-link" href="../../4.optimizacion_en_redes_y_prog_lineal/4.1/Programacion_lineal_y_metodo_simplex.html" title="next page">4.1 Programación lineal (PL) y método símplex</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Erick Palacios Moreno<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>