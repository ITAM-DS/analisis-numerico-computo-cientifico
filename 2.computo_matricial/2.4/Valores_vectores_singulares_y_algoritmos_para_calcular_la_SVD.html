
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2.4 Valores, vectores singulares y algoritmos para calcular la SVD</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.5f77b4aec8189eecf79907ce328c390d.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe,.cell"
        const thebe_selector_input = "pre,.cell_input div.highlight"
        const thebe_selector_output = ".output,.cell_output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="3.1 Definición de problemas de optimización, conjuntos y funciones convexas" href="../../3.optimizacion_convexa/3.1/Definicion_de_problema_optimizacion_conjuntos_y_funciones_convexas.html" />
    <link rel="prev" title="2.3 Algoritmos y aplicaciones de eigenvalores y eigenvectores de una matriz" href="../2.3/Algoritmos_y_aplicaciones_de_eigenvalores_eigenvectores_de_una_matriz.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
      <img src="../../_static/logo.png" class="logo" alt="logo">
      
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../README.html">
   Optimización
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  1. Cómputo científico
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../1.computo_cientifico/1.1/Analisis_numerico_y_computo_cientifico.html">
   1.1 Análisis numérico y cómputo científico
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../1.computo_cientifico/1.2/Sistema_de_punto_flotante.html">
   1.2 Sistema de punto flotante
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../1.computo_cientifico/1.3/Normas_vectoriales_y_matriciales.html">
   1.3 Normas vectoriales y matriciales
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../1.computo_cientifico/1.4/Condicion_de_un_problema_y_estabilidad_de_un_algoritmo.html">
   1.4 Condición de un problema y estabilidad de un algoritmo
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../1.computo_cientifico/1.5/Definicion_de_funcion_continuidad_derivada.html">
   1.5 Definición de función, continuidad y derivada
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../1.computo_cientifico/1.6/Polinomios_de_Taylor_y_diferenciacion_numerica.html">
   1.6 Polinomios de Taylor y diferenciación numérica
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../1.computo_cientifico/1.7/Integracion_numerica.html">
   1.7 Integración Numérica
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  2. Cómputo matricial
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../2.1/Operaciones_y_transformaciones_basicas_del_Algebra_Lineal_Numerica.html">
   2.1 Operaciones y transformaciones básicas del Álgebra Lineal Numérica
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../2.2/Eigenvalores_y_eigenvectores.html">
   2.2 Eigenvalores y eigenvectores
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../2.3/Algoritmos_y_aplicaciones_de_eigenvalores_eigenvectores_de_una_matriz.html">
   2.3 Algoritmos y aplicaciones de eigenvalores y eigenvectores de una matriz
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   2.4 Valores, vectores singulares y algoritmos para calcular la SVD
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  3. Optimización convexa y ecuaciones no lineales
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../3.optimizacion_convexa/3.1/Definicion_de_problema_optimizacion_conjuntos_y_funciones_convexas.html">
   3.1 Definición de problemas de optimización, conjuntos y funciones convexas
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../3.optimizacion_convexa/3.2/Algoritmos_de_descenso_y_busqueda_de_linea_en_uco.html">
   3.2 Algoritmos de descenso y búsqueda de línea en
   <em>
    Unconstrained Convex Optimization
   </em>
   (UCO)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../3.optimizacion_convexa/3.3/Ejemplos_problemas_UCO_e_intro_CIEO_y_PI.html">
   3.3 Ejemplos de problemas UCO, introducción a
   <em>
    Constrained Inequality and Equality Optimization
   </em>
   (CIEO) y puntos interiores
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../3.optimizacion_convexa/3.4/Ecuaciones_no_lineales.html">
   3.4 Ecuaciones no lineales
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  4. Optimización en redes y programación lineal
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../4.optimizacion_en_redes_y_prog_lineal/4.1/Programacion_lineal_y_metodo_simplex.html">
   4.1 Programación lineal (PL) y método símplex
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../4.optimizacion_en_redes_y_prog_lineal/4.2/Definiciones_generales_de_flujo_en_redes.html">
   4.2 Definiciones generales de flujo en redes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../4.optimizacion_en_redes_y_prog_lineal/4.3/Ejemplo_metodo_simplex_de_redes.html">
   4.3 Ejemplo del método símplex de redes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../4.optimizacion_en_redes_y_prog_lineal/4.4/Dualidad_lema_de_Farkas_condiciones_KKT_de_optimalidad.html">
   4.4 Dualidad, lema de Farkas y condiciones de Karush-Kuhn-Tucker (KKT) de optimalidad
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../4.optimizacion_en_redes_y_prog_lineal/4.5/Metodo_primal_dual_de_BL.html">
   4.5 Método primal-dual de barrera logarítmica (BL)
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  5. Optimización de código
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../5.optimizacion_de_codigo/5.1/introduccion_optimizacion_de_codigo.html">
   5.1 Introducción a optimización de código
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../5.optimizacion_de_codigo/5.2/Herramientas_de_lenguajes_y_del_SO_para_perfilamiento_e_implementaciones_de_BLAS.html">
   5.2 Herramientas de lenguajes de programación y del sistema operativo para perfilamiento e implementaciones de BLAS
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../5.optimizacion_de_codigo/5.3/Compilacion_a_C.html">
   5.3 Compilación a C
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../5.optimizacion_de_codigo/5.4/Computo_en_paralelo_usando_CPUS_en_SMC.html">
   5.4 Cómputo en paralelo usando CPUs en un sistema de memoria compartida (SMC)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../5.optimizacion_de_codigo/5.5/Computo_en_paralelo_usando_GPUS_en_SMC.html">
   5.5 Cómputo en paralelo usando GPUs en un sistema de memoria compartida (SMC)
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  6. Algoritmos de optimización convexa
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../6.algoritmos_optimizacion_convexa/6.1/Problemas_UCO.html">
   6.1 Problemas tipo
   <em>
    Unconstrained Convex Optimization
   </em>
   (UCO)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../6.algoritmos_optimizacion_convexa/6.2/Problemas_CECO.html">
   6.2 Problemas tipo
   <em>
    Constrained Equality Convex Optimization
   </em>
   (CECO)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../6.algoritmos_optimizacion_convexa/6.3/Problemas_CIECO.html">
   6.3 Problemas tipo
   <em>
    Constrained Equality and Inequality Convex Optimization
   </em>
   (CIECO)
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  7. Temas selectos
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../7.temas_selectos/7.1/Optimizacion_estocastica.html">
   7.1 Optimización estocástica
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../7.temas_selectos/7.2/Metodos_cuasi_Newton.html">
   7.2 Métodos cuasi Newton
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/2.computo_matricial/2.4/Valores_vectores_singulares_y_algoritmos_para_calcular_la_SVD.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/palmoreck/dockerfiles-for-binder/jupyterlab_optimizacion_2?urlpath=lab/tree/analisis-numerico-computo-cientifico/libro_optimizacion/temas/2.computo_matricial/2.4/Valores_vectores_singulares_y_algoritmos_para_calcular_la_SVD.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        <button type="button" class="btn btn-secondary topbarbtn"
            onclick="initThebeSBT()" title="Launch Thebe" data-toggle="tooltip" data-placement="left"><i
                class="fas fa-play"></i><span style="margin-left: .4em;">Live Code</span></button>
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#valor-singular">
   Valor singular
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#vector-singular-izquierdo-vector-singular-derecho">
   Vector singular izquierdo, vector singular derecho
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#descomposicion-en-valores-singulares-svd">
   Descomposición en valores singulares (SVD)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#algunas-propiedades">
   Algunas propiedades
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#algunas-aplicaciones">
   Algunas aplicaciones
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ejemplo-componentes-principales">
     Ejemplo: componentes principales
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metodos-numericos-para-calcular-svd">
   Métodos numéricos para calcular SVD
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metodo-de-rotaciones-de-jacobi-one-sided">
   Método de rotaciones de Jacobi
   <em>
    one sided
   </em>
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#algoritmo-metodo-de-rotaciones-de-jacobi-one-sided">
     Algoritmo: Método de rotaciones de Jacobi
     <em>
      one sided
     </em>
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="valores-vectores-singulares-y-algoritmos-para-calcular-la-svd">
<span id="valvecsingalgsvd"></span><h1>2.4 Valores, vectores singulares y algoritmos para calcular la SVD<a class="headerlink" href="#valores-vectores-singulares-y-algoritmos-para-calcular-la-svd" title="Permalink to this headline">¶</a></h1>
<div class="admonition-notas-para-contenedor-de-docker admonition">
<p class="admonition-title">Notas para contenedor de docker:</p>
<p>Comando de docker para ejecución de la nota de forma local:</p>
<p>nota: cambiar <code class="docutils literal notranslate"><span class="pre">&lt;ruta</span> <span class="pre">a</span> <span class="pre">mi</span> <span class="pre">directorio&gt;</span></code> por la ruta de directorio que se desea mapear a <code class="docutils literal notranslate"><span class="pre">/datos</span></code> dentro del contenedor de docker y <code class="docutils literal notranslate"><span class="pre">&lt;versión</span> <span class="pre">imagen</span> <span class="pre">de</span> <span class="pre">docker&gt;</span></code> por la versión más actualizada que se presenta en la documentación.</p>
<p><code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span> <span class="pre">--rm</span> <span class="pre">-v</span> <span class="pre">&lt;ruta</span> <span class="pre">a</span> <span class="pre">mi</span> <span class="pre">directorio&gt;:/datos</span> <span class="pre">--name</span> <span class="pre">jupyterlab_optimizacion</span> <span class="pre">-p</span> <span class="pre">8888:8888</span> <span class="pre">-d</span> <span class="pre">palmoreck/jupyterlab_optimizacion:&lt;versión</span> <span class="pre">imagen</span> <span class="pre">de</span> <span class="pre">docker&gt;</span></code></p>
<p>password para jupyterlab: <code class="docutils literal notranslate"><span class="pre">qwerty</span></code></p>
<p>Detener el contenedor de docker:</p>
<p><code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">stop</span> <span class="pre">jupyterlab_optimizacion</span></code></p>
<p>Documentación de la imagen de docker <code class="docutils literal notranslate"><span class="pre">palmoreck/jupyterlab_optimizacion:&lt;versión</span> <span class="pre">imagen</span> <span class="pre">de</span> <span class="pre">docker&gt;</span></code> en <a class="reference external" href="https://github.com/palmoreck/dockerfiles/tree/master/jupyterlab/optimizacion">liga</a>.</p>
</div>
<hr class="docutils" />
<p>Nota generada a partir de <a class="reference external" href="https://www.dropbox.com/s/s4ch0ww1687pl76/3.2.2.Factorizaciones_matriciales_SVD_Cholesky_QR.pdf?dl=0">liga</a>.</p>
<div class="tip admonition">
<p class="admonition-title">Al final de esta nota el y la lectora:</p>
<ul class="simple">
<li><p>Aprenderá algunas definiciones y resultados de los valores y vectores singulares.</p></li>
<li><p>Comprenderá la relación entre la descomposición de valores singulares de una matriz y las componentes principales desde una perspectiva algebraica. Así también tendrá definiciones utilizadas en Estadística para este último tema.</p></li>
<li><p>Aprenderá la definición de matriz definida y semidefinida positiva.</p></li>
<li><p>Se proporcionará una lista de algoritmos para calcular la descomposición en valores singulares.</p></li>
</ul>
</div>
<p>En esta nota <strong>asumimos</strong> que <span class="math notranslate nohighlight">\(A \in \mathbb{R}^{m \times n}\)</span>.</p>
<div class="section" id="valor-singular">
<h2>Valor singular<a class="headerlink" href="#valor-singular" title="Permalink to this headline">¶</a></h2>
<div class="admonition-definicion admonition">
<p class="admonition-title">Definición</p>
<p>El número <span class="math notranslate nohighlight">\(\sigma\)</span> se denomina valor <em>singular</em> de <span class="math notranslate nohighlight">\(A\)</span> si <span class="math notranslate nohighlight">\(\sigma = \sqrt{\lambda_{A^TA}} = \sqrt{\lambda_{AA^T}}\)</span> donde: <span class="math notranslate nohighlight">\(\lambda_{A^TA}\)</span> y <span class="math notranslate nohighlight">\(\lambda_{AA^T}\)</span> es eigenvalor de <span class="math notranslate nohighlight">\(A^TA\)</span> y <span class="math notranslate nohighlight">\(AA^T\)</span> respectivamente.</p>
</div>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<p>La definición se realiza sobre <span class="math notranslate nohighlight">\(A^TA\)</span> o <span class="math notranslate nohighlight">\(AA^T\)</span> pues éstas matrices tienen el mismo espectro y además sus eigenvalores son reales y no negativos por lo que <span class="math notranslate nohighlight">\(\sigma \in \mathbb{R}\)</span> y de hecho <span class="math notranslate nohighlight">\(\sigma \geq 0\)</span> (la raíz cuadrada se calcula para un eigenvalor no negativo).</p>
</div>
</div>
<div class="section" id="vector-singular-izquierdo-vector-singular-derecho">
<h2>Vector singular izquierdo, vector singular derecho<a class="headerlink" href="#vector-singular-izquierdo-vector-singular-derecho" title="Permalink to this headline">¶</a></h2>
<div class="admonition-definicion admonition">
<p class="admonition-title">Definición</p>
<p>Asociado con cada valor singular <span class="math notranslate nohighlight">\(\sigma\)</span> existen vectores singulares <span class="math notranslate nohighlight">\(u,v\)</span> que cumplen con la igualdad:</p>
<div class="math notranslate nohighlight">
\[Av = \sigma u .\]</div>
<p>Al vector <span class="math notranslate nohighlight">\(u\)</span> se le nombra <strong>vector singular izquierdo</strong> y al vector <span class="math notranslate nohighlight">\(v\)</span> se le nombra <strong>vector singular derecho</strong>.</p>
</div>
</div>
<div class="section" id="descomposicion-en-valores-singulares-svd">
<h2>Descomposición en valores singulares (SVD)<a class="headerlink" href="#descomposicion-en-valores-singulares-svd" title="Permalink to this headline">¶</a></h2>
<p>Si <span class="math notranslate nohighlight">\(A \in \mathbb{R}^{mxn}\)</span> entonces existen <span class="math notranslate nohighlight">\(U \in \mathbb{R}^{mxm}, V \in \mathbb{R}^{nxn}\)</span> <strong>ortogonales</strong> tales que: <span class="math notranslate nohighlight">\(A = U\Sigma V^T\)</span> con <span class="math notranslate nohighlight">\(\Sigma = diag(\sigma_1, \sigma_2, \dots, \sigma_p) \in \mathbb{R}^{mxn}\)</span>, <span class="math notranslate nohighlight">\(p = \min\{m,n\}\)</span> y <span class="math notranslate nohighlight">\(\sigma_1 \geq \sigma_2 \geq \dots \geq \sigma_p \geq 0\)</span>.</p>
<p>Por ejemplo para un caso <span class="math notranslate nohighlight">\(m &lt; n\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\left [
\begin{array}{ccc}
a_{11} &amp; a_{12} &amp; a_{13}\\
a_{21} &amp; a_{22} &amp; a_{23}
\end{array}
\right ]
=
\left [
\begin{array}{cc}
u_{11} &amp; u_{12}\\
u_{21} &amp; u_{22}
\end{array}
\right ]
\left [
\begin{array}{ccc}
\sigma_1 &amp; 0 &amp; 0\\
0 &amp; \sigma_2 &amp; 0
\end{array}
\right ]
\left [
\begin{array}{ccc}
v_{11} &amp; v_{21} &amp; v_{31}\\
v_{12} &amp; v_{22} &amp; v_{32}\\
v_{13} &amp; v_{23} &amp; v_{33}
\end{array}
\right ]
\end{split}\]</div>
<p>y para un caso <span class="math notranslate nohighlight">\(m &gt; n\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\left [
\begin{array}{cc}
a_{11} &amp; a_{12}\\
a_{21} &amp; a_{22}\\
a_{31} &amp; a_{32}
\end{array}
\right ]
=
\left [
\begin{array}{ccc}
u_{11} &amp; u_{12} &amp; u_{13}\\
u_{21} &amp; u_{22} &amp; u_{23}\\
u_{31} &amp; u_{32} &amp; u_{33}
\end{array}
\right ]
\left [
\begin{array}{cc}
\sigma_1 &amp; 0\\
0 &amp; \sigma_2\\
0 &amp; 0
\end{array}
\right ]
\left [
\begin{array}{cc}
v_{11} &amp; v_{21}\\
v_{12} &amp; v_{22}\\
\end{array}
\right ]
\end{split}\]</div>
<div class="admonition-definicion admonition">
<p class="admonition-title">Definición</p>
<p>Las columnas de <span class="math notranslate nohighlight">\(U\)</span> nombramos <strong>vectores singulares izquierdos de <span class="math notranslate nohighlight">\(A\)</span></strong> y las columnas de <span class="math notranslate nohighlight">\(V\)</span> nombramos <strong>vectores singulares derechos de <span class="math notranslate nohighlight">\(A\)</span></strong> en <span class="math notranslate nohighlight">\(A = U \Sigma V^T\)</span>.</p>
</div>
<div class="admonition-comentarios admonition">
<p class="admonition-title">Comentarios</p>
<ul class="simple">
<li><p>La notación <span class="math notranslate nohighlight">\(\sigma_1\)</span> hace referencia al valor singular más grande de A, <span class="math notranslate nohighlight">\(\sigma_2\)</span> al segundo valor singular más grande de A y así sucesivamente.</p></li>
<li><p>Para cualquier <span class="math notranslate nohighlight">\(A \in \mathbb{R}^{m \times n}\)</span> se tiene <span class="math notranslate nohighlight">\(A = U \Sigma V^T\)</span>. Si <span class="math notranslate nohighlight">\(b = Ax = (U \Sigma V^T) x\)</span> entonces:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\tilde{b} = U^Tb = U^T  (Ax) = U^T (U \Sigma V^T) x = \Sigma V^Tx = \Sigma \tilde{x}.\]</div>
<p>Lo anterior indica que el producto matricial <span class="math notranslate nohighlight">\(Ax\)</span> para cualquier matriz <span class="math notranslate nohighlight">\(A\)</span> es equivalente a multiplicar una matriz diagonal por un vector denotado como <span class="math notranslate nohighlight">\(\tilde{x}\)</span> que contiene los coeficientes de la combinación lineal de las columnas de <span class="math notranslate nohighlight">\(V\)</span> para el vector <span class="math notranslate nohighlight">\(x\)</span> . El resultado de tal multiplicación es un vector denotado como <span class="math notranslate nohighlight">\(\tilde{b}\)</span> que contiene los coeficientes de la combinación lineal de las columnas de <span class="math notranslate nohighlight">\(U\)</span> para el vector <span class="math notranslate nohighlight">\(b\)</span>. En resúmen, la multiplicación <span class="math notranslate nohighlight">\(Ax\)</span> es equivalente a la multiplicación por una matriz diagonal <span class="math notranslate nohighlight">\(\Sigma \tilde{x}\)</span> salvo dos cambios de bases, ver <a class="reference external" href="https://en.wikipedia.org/wiki/Change_of_basis">Change of basis</a>, la base de los vectores singulares derechos (columnas de <span class="math notranslate nohighlight">\(V\)</span>) y la base de los vectores singulares izquierdos (columnas de <span class="math notranslate nohighlight">\(U\)</span>).</p>
<ul class="simple">
<li><p>La SVD que se definió arriba es nombrada <em>SVD full</em>, hay otras formas como la <strong>truncada</strong> en la que <span class="math notranslate nohighlight">\(U \in \mathbb{R}^{m \times k}\)</span>, <span class="math notranslate nohighlight">\(V \in \mathbb{R}^{nxk}\)</span> y <span class="math notranslate nohighlight">\(\Sigma \in \mathbb{R}^{k \times k}\)</span> con <span class="math notranslate nohighlight">\(k \leq r\)</span>, <strong>compacta</strong> donde <span class="math notranslate nohighlight">\(k=r\)</span> y la <em>thin</em> en la que <span class="math notranslate nohighlight">\(k=p\)</span>:</p></li>
</ul>
<img src="https://dl.dropboxusercontent.com/s/8dq0jiw5em93k1j/svd_thin.png?dl=0" heigth="700" width="700">
<p>donde: <span class="math notranslate nohighlight">\(r = rank(A)\)</span>.</p>
<p>Ver <a class="reference external" href="https://en.wikipedia.org/wiki/Singular_value_decomposition#Reduced_SVDs">reduced SVDs</a>.</p>
</div>
</div>
<div class="section" id="algunas-propiedades">
<h2>Algunas propiedades<a class="headerlink" href="#algunas-propiedades" title="Permalink to this headline">¶</a></h2>
<p>Existen diferentes propiedades de los valores y vectores singulares, aquí se enlistan algunas:</p>
<ul class="simple">
<li><p>Si <span class="math notranslate nohighlight">\(rank(A) = r\)</span> entonces <span class="math notranslate nohighlight">\(r \leq p\)</span> y <span class="math notranslate nohighlight">\(\sigma_1 \geq \sigma_2 \geq \dots \geq \sigma_r &gt; \sigma_{r+1} = \sigma_{r+2} = \dots = \sigma_p =  0\)</span>.</p></li>
<li><p>Si <span class="math notranslate nohighlight">\(rank(A) = r\)</span> entonces <span class="math notranslate nohighlight">\(A = \displaystyle \sum_{i=0}^r \sigma_i u_i v_i^T\)</span> con <span class="math notranslate nohighlight">\(u_i\)</span> <span class="math notranslate nohighlight">\(i\)</span>-ésima columna de U y <span class="math notranslate nohighlight">\(v_i\)</span> <span class="math notranslate nohighlight">\(i\)</span>-ésima columna de V.</p></li>
<li><p>Geométricamente los valores singulares de una matriz <span class="math notranslate nohighlight">\(A \in \mathbb{R}^{mxn}\)</span> son las longitudes de los semiejes del hiperelipsoide <span class="math notranslate nohighlight">\(E\)</span> definido por <span class="math notranslate nohighlight">\(E = \{Ax : ||x||_2 \leq 1\}\)</span> y los vectores <span class="math notranslate nohighlight">\(u_i\)</span> son direcciones de estos semiejes; los vectores <span class="math notranslate nohighlight">\(vi\)</span>’s tienen norma igual a <span class="math notranslate nohighlight">\(1\)</span> por lo que se encuentran en una circunferencia de radio igual a <span class="math notranslate nohighlight">\(1\)</span> y como <span class="math notranslate nohighlight">\(Av_i = \sigma u_i\)</span> entonces <span class="math notranslate nohighlight">\(A\)</span> mapea los vectores <span class="math notranslate nohighlight">\(v_i\)</span>’s a los semiejes <span class="math notranslate nohighlight">\(u_i\)</span>’s respectivamente:</p></li>
</ul>
<img src="https://dl.dropboxusercontent.com/s/1yqoe4qibyyej53/svd_2.jpg?dl=0" heigth="700" width="700"><ul class="simple">
<li><p>La SVD da bases ortogonales para los <span class="math notranslate nohighlight">\(4\)</span> espacios fundamentales de una matriz: espacio columna, espacio nulo izquierdo, espacio nulo y espacio renglón:</p></li>
</ul>
<img src="https://dl.dropboxusercontent.com/s/uo9s9f0nqi43s6d/svd_four_spaces_of_matrix.png?dl=0" heigth="600" width="600">
<ul class="simple">
<li><p>Si <span class="math notranslate nohighlight">\(t &lt; r\)</span> y <span class="math notranslate nohighlight">\(r=rank(A)\)</span> entonces <span class="math notranslate nohighlight">\(A_t =  \displaystyle \sum_{i=0}^t \sigma_i u_i v_i^T\)</span> (SVD truncada) es una matriz de entre todas las matrices con <span class="math notranslate nohighlight">\(rank\)</span> igual a t, que es más <em>cercana</em> a A. La cercanía se mide con la norma <strong>matricial</strong> Euclidiana y de Frobenius, en el caso de Frobenius es la única matriz que cumple lo anterior.</p></li>
</ul>
</div>
<div class="section" id="algunas-aplicaciones">
<h2>Algunas aplicaciones<a class="headerlink" href="#algunas-aplicaciones" title="Permalink to this headline">¶</a></h2>
<p>Algunas de las aplicaciones de la SVD se encuentran:</p>
<ul class="simple">
<li><p>Procesamiento de imágenes y señales.</p></li>
<li><p>Sistemas de recomendación (Netflix).</p></li>
<li><p>Mínimos cuadrados.</p></li>
<li><p>Componentes principales.</p></li>
<li><p>Reconstrucción de imágenes.</p></li>
</ul>
<div class="section" id="ejemplo-componentes-principales">
<h3>Ejemplo: componentes principales<a class="headerlink" href="#ejemplo-componentes-principales" title="Permalink to this headline">¶</a></h3>
<p>Considérese <span class="math notranslate nohighlight">\(X \in \mathbb{R}^{m \times n}\)</span> cuyas columnas tienen una observación de un <strong>vector aleatorio</strong> (tenemos <span class="math notranslate nohighlight">\(n\)</span> vectores aleatorios de mediciones) y <span class="math notranslate nohighlight">\(X = U \Sigma V^T\)</span> la descomposición en valores singulares de <span class="math notranslate nohighlight">\(X\)</span>, entonces los vectores <strong>singulares derechos</strong> <span class="math notranslate nohighlight">\(v_i\)</span> (columnas de la matriz <span class="math notranslate nohighlight">\(V\)</span>) son nombrados <strong>ejes o direcciones principales</strong> de <span class="math notranslate nohighlight">\(X\)</span> y el vector <span class="math notranslate nohighlight">\(z_1 = X v_1 = \sigma_1 u_1\)</span> con <span class="math notranslate nohighlight">\(u_1\)</span> vector <strong>singular izquierdo</strong> (primera columna de la matriz <span class="math notranslate nohighlight">\(U\)</span>) tiene <strong>varianza muestral</strong>:</p>
<div class="math notranslate nohighlight">
\[\text{var}(z_1) = \text{var}(X v_1)= \text{var}(\sigma_1 u_1) = \sigma_1^2 \text{var}(u_1) = \sigma_1^2 \left [ \frac{1}{m} \displaystyle \sum_{i=1}^m (u_1(i) - \bar{u}_1)^2 \right ]\]</div>
<p>donde: <span class="math notranslate nohighlight">\(u_1(i)\)</span> es la <span class="math notranslate nohighlight">\(i\)</span>-ésima componente de <span class="math notranslate nohighlight">\(u_1\)</span> y <span class="math notranslate nohighlight">\(\sigma_1\)</span> es el máximo valor singular de <span class="math notranslate nohighlight">\(X\)</span> también denotado como <span class="math notranslate nohighlight">\(\sigma_{\text{max}}\)</span>.</p>
<div class="admonition-comentarios admonition">
<p class="admonition-title">Comentarios</p>
<p>Si la media de cada columna de <span class="math notranslate nohighlight">\(X\)</span> es cero, <span class="math notranslate nohighlight">\(X\)</span> se nombra <strong>centrada</strong>, entonces:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(z_1\)</span> tiene la <strong>máxima varianza muestral</strong> entre todas las combinaciones lineales de las columnas de <span class="math notranslate nohighlight">\(X\)</span> pues:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\text{var}(z_1) = \frac{\sigma_1^2}{m} \displaystyle \sum_{i=1}^m u_1(i)^2 = \frac{\sigma_1^2}{m} ||u_1||_2^2 = \frac{\sigma_1^2}{m}.\]</div>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(z_1\)</span> es la <strong>primera componente principal</strong> y el vector <span class="math notranslate nohighlight">\(u_1 = \frac{1}{\sigma_1}z_1 = \frac{1}{\sigma_1}Xv_1\)</span> se le nombra <strong>primera componente principal normalizada</strong>. El vector <span class="math notranslate nohighlight">\(v_1\)</span> es la <strong>primera dirección principal</strong> de <span class="math notranslate nohighlight">\(X\)</span> o también nombrada <em><strong>loading</strong></em>.</p></li>
</ul>
</div>
<p>Algunas definiciones utilizadas en Estadística se encuentran las siguientes.</p>
<div class="admonition-definicion admonition">
<p class="admonition-title">Definición</p>
<p>La <strong>matriz de correlaciones entre cada componente principal normalizada <span class="math notranslate nohighlight">\(u\)</span>’s y cada columna de <span class="math notranslate nohighlight">\(X\)</span></strong> es:</p>
<div class="math notranslate nohighlight">
\[ C = \left (\frac{\sigma_1}{\sqrt{m}} v_1 \quad \frac{\sigma_2}{\sqrt{m}} v_2 \cdots \quad \frac{\sigma_n}{\sqrt{m}} v_n \right) \in \mathbb{R}^{n \times n}\]</div>
<p>pues si <span class="math notranslate nohighlight">\(x_1\)</span> es la primer columna de <span class="math notranslate nohighlight">\(X\)</span> entonces:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{eqnarray}
\text{cov}(x_1,u_1) = \text{cov} \left ( \displaystyle \sum_{k=1}^n \sigma_k v_k(1) u_k, u_1 \right ) &amp;=&amp; \displaystyle \sum_{k=1}^n \text{cov} ( \sigma_k v_k(1) u_k, u_1 ) \nonumber \\
&amp;=&amp; \displaystyle \sum_{k=1}^n \sigma_k v_k(1) \text{cov} (u_k, u_1) \nonumber \\
&amp;=&amp; \sigma_1 v_1(1) \text{var}(u_1) \nonumber \\
&amp;=&amp; \frac{\sigma_1 v_1(1)}{m} \sum_{i=1}^m u_1(i)^2 \nonumber \\
&amp;=&amp; \frac{\sigma_1 v_1(1)}{m} \nonumber
\end{eqnarray}
\end{split}\]</div>
<p>Y como <span class="math notranslate nohighlight">\(\text{cor}(x_1,u_1) = \frac{\text{cov}(x_1,u_1)}{\sqrt{\text{var}(x_1)} \sqrt{\text{var}(u_1)}}\)</span> se tiene:</p>
<div class="math notranslate nohighlight">
\[\text{cor}(x_1,u_1) = \frac{\frac{\sigma_1 v_1(1)}{m}}{1 \cdot \sqrt{\frac{1}{m}}}  = \frac{\sigma_1 v_1(1)}{\sqrt{m}} \]</div>
</div>
<div class="admonition-definicion admonition">
<p class="admonition-title">Definición</p>
<p>El cociente de <strong>varianza explicada</strong> para cada componente es el número:</p>
<div class="math notranslate nohighlight">
\[\frac{\sigma_i^2}{\displaystyle \sum_{i=1}^p \sigma_i^2}\]</div>
<p>con <span class="math notranslate nohighlight">\(p = \min(m,n)\)</span>.</p>
</div>
<div class="tip admonition">
<p class="admonition-title">Observación</p>
<p>la matriz <span class="math notranslate nohighlight">\(\frac{1}{m}X^TX\)</span> es la matriz de <strong>varianzas y covarianzas muestral</strong> la cual <strong>siempre</strong> es una matriz simétrica positiva semidefinida (aún si la <span class="math notranslate nohighlight">\(X\)</span> no es centrada). Si <span class="math notranslate nohighlight">\(X\)</span> además de ser centrada cumple que la varianza de cada una de sus columnas es <span class="math notranslate nohighlight">\(1\)</span>, <span class="math notranslate nohighlight">\(X\)</span> se nombra <strong>estandarizada</strong>. La matriz <span class="math notranslate nohighlight">\(\frac{1}{m}X^TX\)</span> en este caso es la matriz de <strong>correlaciones muestral</strong>.</p>
</div>
<div class="admonition-definicion admonition" id="matrizsdpositiva">
<p class="admonition-title">Definición</p>
<p>Una matriz <span class="math notranslate nohighlight">\(A\)</span> es semidefinida positiva si <span class="math notranslate nohighlight">\(x^TAx \geq 0\)</span> <span class="math notranslate nohighlight">\(\forall x \in \mathbb{R}^n - \{0\}\)</span>. Si se cumple de forma estricta la desigualdad entonces <span class="math notranslate nohighlight">\(A\)</span> es <strong>definida positiva</strong>. Con los eigenvalores podemos caracterizar a las matrices definidas y semidefinidas positivas: <span class="math notranslate nohighlight">\(A\)</span> es semidefinida positiva si y sólo si los eigenvalores de <span class="math notranslate nohighlight">\(T=\frac{A+A^T}{2}\)</span> son no negativos. Es definida positiva si y sólo si los eigenvalores de <span class="math notranslate nohighlight">\(T\)</span> son positivos. Los conjuntos de matrices que se utilizan para definir a matrices simétricas semidefinidas positivas y simétricas definidas positivas son <span class="math notranslate nohighlight">\(\mathbb{S}_{+}^n\)</span> y <span class="math notranslate nohighlight">\(\mathbb{S}_{++}^n\)</span> respectivamente (<span class="math notranslate nohighlight">\(\mathbb{S}\)</span> es el conjunto de matrices simétricas).</p>
</div>
<div class="cell tag_margin docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span>pip install --quiet sklearn
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span><span class=" -Color -Color-Yellow">WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by &#39;NewConnectionError(&#39;&lt;pip._vendor.urllib3.connection.HTTPSConnection object at 0x7f21d7e24100&gt;: Failed to establish a new connection: [Errno -2] Name or service not known&#39;)&#39;: /simple/sklearn/</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">2020</span><span class="p">)</span>
<span class="n">mpoints</span><span class="o">=</span><span class="mi">200</span>
<span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="nd">@np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="mi">2</span><span class="p">,</span><span class="n">mpoints</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/Valores_vectores_singulares_y_algoritmos_para_calcular_la_SVD_38_0.png" src="../../_images/Valores_vectores_singulares_y_algoritmos_para_calcular_la_SVD_38_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">svd_solver</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
<span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>PCA(n_components=2, svd_solver=&#39;full&#39;)
</pre></div>
</div>
</div>
</div>
<p><strong>Direcciones o ejes principales</strong>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">components_</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 0.91945871  0.39318658]
 [ 0.39318658 -0.91945871]]
</pre></div>
</div>
</div>
</div>
<p><strong>Varianza explicada por cada componente (primera posición para la primera componente):</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0.99029474 0.00970526]
</pre></div>
</div>
</div>
</div>
<p><strong>Valores singulares de la matriz <span class="math notranslate nohighlight">\(X\)</span>:</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pca</span><span class="o">.</span><span class="n">singular_values_</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([18.68043742,  1.84930434])
</pre></div>
</div>
</div>
</div>
<p><strong>Componentes principales con el método <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html#sklearn.decomposition.PCA.transform">transform</a> de <code class="docutils literal notranslate"><span class="pre">scikit-learn.PCA</span></code>:</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(200, 2)
</pre></div>
</div>
</div>
</div>
<p><strong>Primera componente:</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z1</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([-0.73286192, -0.10931069, -0.5294992 , -1.62049625, -0.55137898,
        0.42135363,  0.07424362, -0.29822525, -1.73357019, -0.56416428])
</pre></div>
</div>
</div>
</div>
<p><strong>Segunda componente:</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z2</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z2</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([ 0.14574216,  0.11652276,  0.12040267,  0.08249224, -0.0437718 ,
        0.03168412, -0.07123458,  0.08183026, -0.02113837, -0.31235302])
</pre></div>
</div>
</div>
</div>
<p>Usemos el método de <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.svd.html#numpy.linalg.svd">SVD</a> del paquete <code class="docutils literal notranslate"><span class="pre">numpy</span></code> para revisar lo que nos devuelve y observar que son iguales sus resultados:</p>
<p>Primero centramos a la <span class="math notranslate nohighlight">\(X\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_centered</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>No olvidemos que el método de <code class="docutils literal notranslate"><span class="pre">numpy</span></code> nos devuelve <span class="math notranslate nohighlight">\(V^T\)</span> y no <span class="math notranslate nohighlight">\(V\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">u</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">vt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">X_centered</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><strong>Los valores singulares están dados por la diagonal de <span class="math notranslate nohighlight">\(\Sigma\)</span>:</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">singular_values_</span><span class="p">,</span><span class="n">s</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ True  True]
</pre></div>
</div>
</div>
</div>
<p><strong>Las direcciones principales están dadas por las columnas de <span class="math notranslate nohighlight">\(V\)</span> (salvo signos positivos o negativos):</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">components_</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]),</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vt</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ True  True]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">components_</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]),</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vt</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ True  True]
</pre></div>
</div>
</div>
</div>
<p><strong>Las componentes principales están dadas por la multiplicación matricial <span class="math notranslate nohighlight">\(XV\)</span> (salvo signos positivos o negativos):</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z_manual</span> <span class="o">=</span> <span class="n">X_centered</span><span class="o">@</span><span class="p">(</span><span class="n">vt</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z1_manual</span> <span class="o">=</span> <span class="n">z_manual</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z1_manual</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z2_manual</span> <span class="o">=</span> <span class="n">z_manual</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z2_manual</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True]
</pre></div>
</div>
</div>
</div>
<p><strong>También podemos hacer la multiplicación <span class="math notranslate nohighlight">\(\sigma u\)</span> (salvo signos positivos o negativos):</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z1_manual_2</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">u</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z1_manual_2</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z2_manual_2</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">u</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z2_manual_2</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True]
</pre></div>
</div>
</div>
</div>
<p><strong>La varianza explicada está dada por los valores singulares al cuadrado divididos por la suma de éstos al cuadrado:</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="tip admonition">
<p class="admonition-title">Ejercicios</p>
<ul class="simple">
<li><p>Muestra en la gráfica de la nube de puntos del ejemplo anterior las direcciones principales.</p></li>
<li><p>Genera otra nube de puntos y realiza los pasos del ejemplo anterior (equivalencia entre métodos en los paquetes de <em>Python</em>) junto con la gráfica de las direcciones principales.</p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="metodos-numericos-para-calcular-svd">
<h2>Métodos numéricos para calcular SVD<a class="headerlink" href="#metodos-numericos-para-calcular-svd" title="Permalink to this headline">¶</a></h2>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>En <em>NumPy</em> con <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.svd.html">numpy.linalg.svd</a> podemos calcular la SVD de <span class="math notranslate nohighlight">\(A\)</span>, obsérvese en la ayuda  que se regresa <span class="math notranslate nohighlight">\(V^T\)</span> y no <span class="math notranslate nohighlight">\(V\)</span>.</p>
</div>
<p>Algunos métodos para calcular la descomposición en valores singulares de una matriz son:</p>
<ul class="simple">
<li><p>Método de rotaciones de Jacobi <em><strong>one sided</strong></em>, ver <a class="reference internal" href="../2.3/Algoritmos_y_aplicaciones_de_eigenvalores_eigenvectores_de_una_matriz.html#rotjacmatsim"><span class="std std-ref">rotaciones de Jacobi para matrices simétricas</span></a> en el que se utiliza el <em><strong>two sided</strong></em>.</p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Bidiagonalization">Bidiagonalización</a>.</p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Power_iteration">Método de la potencia</a> en el que se utiliza el <strong><a class="reference external" href="https://en.wikipedia.org/wiki/Rayleigh_quotient">cociente de Rayleigh</a></strong> para acelerar convergencia, ver <a class="reference internal" href="../2.3/Algoritmos_y_aplicaciones_de_eigenvalores_eigenvectores_de_una_matriz.html#mpotmatsim"><span class="std std-ref">método de la potencia para matrices simétricas</span></a> y la <a class="reference internal" href="../2.3/Algoritmos_y_aplicaciones_de_eigenvalores_eigenvectores_de_una_matriz.html#itercraymatsim"><span class="std std-ref">iteración por el cociente de Rayleigh para matrices simétricas</span></a>.</p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/QR_algorithm">Algoritmo QR</a> que se basa en la factorización QR, ver <a class="reference internal" href="../2.3/Algoritmos_y_aplicaciones_de_eigenvalores_eigenvectores_de_una_matriz.html#algqr"><span class="std std-ref">algoritmo QR o QR iteration (versión simple) para matrices simétricas</span></a>.</p></li>
<li><p>Métodos de descenso aplicados a problemas de optimización.</p></li>
<li><p>Para casos particulares como una matriz <span class="math notranslate nohighlight">\(A\)</span> <em>sparse</em> o rala (gran cantidad de ceros) se utilizan algoritmos como <a class="reference external" href="http://www.netlib.org/utk/people/JackDongarra/etemplates/node198.html"><strong>Lanczos Golub Kahan bidiagonalization</strong></a> que forma parte de una amplia clases de métodos nombrados <a class="reference external" href="https://en.wikipedia.org/wiki/Krylov_subspace"><strong>Krylov subspace methods</strong></a> y el algoritmo de <a class="reference external" href="https://en.wikipedia.org/wiki/Lanczos_algorithm"><strong>tridiagonalización Lanczos</strong></a>.</p></li>
</ul>
</div>
<div class="section" id="metodo-de-rotaciones-de-jacobi-one-sided">
<h2>Método de rotaciones de Jacobi <em>one sided</em><a class="headerlink" href="#metodo-de-rotaciones-de-jacobi-one-sided" title="Permalink to this headline">¶</a></h2>
<p>En este método se utilizan rotaciones de Jacobi, ver <a class="reference internal" href="../2.1/Operaciones_y_transformaciones_basicas_del_Algebra_Lineal_Numerica.html#trot"><span class="std std-ref">transformaciones de rotación</span></a>, para construir a la matriz ortogonal <span class="math notranslate nohighlight">\(V \in \mathbb{R}^{n \times n}\)</span> y llegar a una matriz <span class="math notranslate nohighlight">\(W\)</span>:</p>
<div class="math notranslate nohighlight">
\[AV \rightarrow W \in  \mathbb{R}^{m \times n}\]</div>
<div class="admonition-comentario admonition">
<p class="admonition-title">Comentario</p>
<p>Las normas Euclidianas de las columnas de <span class="math notranslate nohighlight">\(W\)</span> construyen a los valores singulares <span class="math notranslate nohighlight">\(\sigma_i \forall i=1,\dots,r\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}W = [U_1 \quad 0]\left[ \begin{array}{cc}
\Sigma &amp; 0\\
0 &amp; 0
\end{array}
\right]\end{split}\]</div>
<p>con <span class="math notranslate nohighlight">\(r=rank(A)\)</span>, <span class="math notranslate nohighlight">\(U_1 \in \mathbb{R}^{m \times r}\)</span> matriz con columnas ortonormales: <span class="math notranslate nohighlight">\(U_1^TU_1=I_r\)</span> y <span class="math notranslate nohighlight">\(\Sigma = diag(\sigma_1,\dots, \sigma_r)\)</span> matriz diagonal.</p>
<p>Esta SVD es una forma compacta.</p>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Los criterios de paro en un método iterativo ayudan a contestar preguntas del tipo ¿hemos resuelto el problema de forma aproximada?</p>
</div>
<div class="section" id="algoritmo-metodo-de-rotaciones-de-jacobi-one-sided">
<h3>Algoritmo: Método de rotaciones de Jacobi <em>one sided</em><a class="headerlink" href="#algoritmo-metodo-de-rotaciones-de-jacobi-one-sided" title="Permalink to this headline">¶</a></h3>
<p>Se denota <span class="math notranslate nohighlight">\(A_k=[a_1^{(k)} a_2^{(k)} \cdots a_n^{(k)}]\)</span> con cada <span class="math notranslate nohighlight">\(a_i^{(k)}\)</span> como <span class="math notranslate nohighlight">\(i\)</span>-ésima columna de <span class="math notranslate nohighlight">\(A\)</span>.</p>
<blockquote>
<div><p><strong>Dados</strong> <span class="math notranslate nohighlight">\(A \in \mathbb{R}^{m \times n}\)</span> y <span class="math notranslate nohighlight">\(tol &gt;0\)</span> <strong>definir</strong> <span class="math notranslate nohighlight">\(A_0 = A\)</span>, <span class="math notranslate nohighlight">\(V_0 = I_n\)</span>.</p>
<p><strong>Repetir</strong> el siguiente bloque para <span class="math notranslate nohighlight">\(k=0,1,2,\dots\)</span></p>
<blockquote>
<div><ol class="simple">
<li><p>Elegir un par de índices <span class="math notranslate nohighlight">\((idx1,idx2)\)</span> con alguna de las metodologías descritas en el bloque siguiente de comentarios.</p></li>
<li><p>Revisar si las columnas <span class="math notranslate nohighlight">\(a_i^{(k)}, a_j^{(k)}\)</span> son ortogonales (el chequeo se describe en los comentarios).</p></li>
<li><p>Si son ortogonales se incrementa por uno la variable <span class="math notranslate nohighlight">\(num\text{_}columnas\text{_}ortogonales\)</span>.</p></li>
<li><p>Si no son ortogonales:</p></li>
</ol>
<blockquote>
<div><p>Calcular <span class="math notranslate nohighlight">\(\left[ \begin{array}{cc} a &amp; d\\ d &amp; b \end{array} \right]\)</span> la submatriz <span class="math notranslate nohighlight">\((i,j)\)</span> de <span class="math notranslate nohighlight">\(A_k^{T}A_k\)</span> donde: <span class="math notranslate nohighlight">\(a = ||a_i^{(k)}||_2^2, b=||a_j^{(k)}||_2^2, d=a_i^{T(k)}a_j^{(k)}\)</span>.</p>
<p>Calcular las entradas <span class="math notranslate nohighlight">\(c: = \cos(\theta), s:=\sin(\theta)\)</span> de la matriz de rotación <span class="math notranslate nohighlight">\(J_k\)</span> que diagonaliza <span class="math notranslate nohighlight">\(\left[ \begin{array}{cc} a &amp; d\\ d &amp; b \end{array} \right]\)</span>.</p>
<p>Actualizar las columnas <span class="math notranslate nohighlight">\(i,j\)</span> de <span class="math notranslate nohighlight">\(A_k\)</span> con la multiplicación <span class="math notranslate nohighlight">\(A_k J_k\)</span> para obtener <span class="math notranslate nohighlight">\(A_{k+1}\)</span>, esto es: <span class="math notranslate nohighlight">\(A_{k+1} = A_k J_k\)</span>.</p>
<p>Actualizar las columnas <span class="math notranslate nohighlight">\(i,j\)</span> de <span class="math notranslate nohighlight">\(V_k\)</span> con la multiplicación <span class="math notranslate nohighlight">\(V_k J_k\)</span> para obtener <span class="math notranslate nohighlight">\(V_{k+1}\)</span>, esto es: <span class="math notranslate nohighlight">\(V_{k+1} = V_k J_k\)</span>.</p>
</div></blockquote>
</div></blockquote>
<p><strong>hasta</strong> convergencia: satisfacer criterio de paro en el que se utiliza <span class="math notranslate nohighlight">\(num\text{_}columnas\text{_}ortogonales\)</span> y <span class="math notranslate nohighlight">\(maxsweeps\)</span>.</p>
</div></blockquote>
<div class="admonition-comentarios admonition">
<p class="admonition-title">Comentarios</p>
<ul class="simple">
<li><p>En el método se hace mención de <strong>metodologías</strong> que ayudan a elegir los índices del renglón y columna del par de entradas de <span class="math notranslate nohighlight">\(A\)</span> que serán eliminadas (hacer cercanas a cero). Algunas de éstas son:</p>
<ul>
<li><p>Elegir <span class="math notranslate nohighlight">\((idx1,idx2)\)</span> tales que <span class="math notranslate nohighlight">\(|a_{idx1,idx2}| = \displaystyle \max_{i \neq j}|a_{ij}|\)</span>.</p></li>
<li><p><strong>Ordenamiento cíclico por renglones:</strong> elegir <span class="math notranslate nohighlight">\((idx1, idx2)\)</span> en el conjunto <span class="math notranslate nohighlight">\((1,2),(1,3),\dots,(1,n),(2,3),(2,4)\dots,(n-1,n)\)</span>.</p></li>
</ul>
</li>
<li><p>En matrices mayores a dos dimensiones el método de rotaciones de Jacobi <em>one sided</em> requiere <strong>ortogonalización repetida</strong> (volver a hacer columnas ortogonales) del par de columnas de <span class="math notranslate nohighlight">\(A\)</span> seleccionadas de iteraciones previas pues en cada iteración vuelven a ser no ortogonales en general.</p></li>
<li><p>¿Cómo revisar si las columnas  <span class="math notranslate nohighlight">\(i,j\)</span> de <span class="math notranslate nohighlight">\(A_k\)</span> son ortogonales?  si se cumple que</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{|a_i^{T (k)}a_j^{(k)}|}{||a_i^{(k)}||_2||a_j^{(k)}||_2} &lt; tol\]</div>
<p>con <span class="math notranslate nohighlight">\(tol\)</span> una cantidad pequeña y positiva (comúnmente menor o igual a <span class="math notranslate nohighlight">\(10^{-8}\)</span>) entonces son ortogonales las columnas <span class="math notranslate nohighlight">\(a_i^{(k)}, a_j^{(k)}\)</span> de <span class="math notranslate nohighlight">\(A_k\)</span>.</p>
<ul class="simple">
<li><p>Las entradas de la matriz <span class="math notranslate nohighlight">\(J_k\)</span> son: <span class="math notranslate nohighlight">\(\tau = \frac{b-a}{2d}, t^*=\frac{signo(\tau)}{|\tau| + \sqrt{1+\tau^2}}, c = \frac{1}{\sqrt{1+t^{*2}}}, s = ct^*\)</span>.</p></li>
<li><p>Para actualizar las columnas <span class="math notranslate nohighlight">\(i,j\)</span> de <span class="math notranslate nohighlight">\(A_k\)</span> de forma eficiente utilizar: para <span class="math notranslate nohighlight">\(\ell\)</span> de <span class="math notranslate nohighlight">\(1\)</span> a <span class="math notranslate nohighlight">\(n\)</span>:</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(temp = A^{(k)}_{\ell i}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(A_{\ell i}^{(k)} = c*temp - s*A_{\ell j}^{(k)}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(A_{\ell j}^{(k)} = s*temp + c*A_{\ell j}^{(k)}\)</span></p></li>
</ul>
</li>
</ul>
<p>con <span class="math notranslate nohighlight">\(A_{\ell i}^{(k)}\)</span> entrada <span class="math notranslate nohighlight">\(\ell, i\)</span> de <span class="math notranslate nohighlight">\(A_k\)</span>.</p>
<ul class="simple">
<li><p>Para actualizar las columnas <span class="math notranslate nohighlight">\(i,j\)</span> de <span class="math notranslate nohighlight">\(V_k\)</span> de forma eficiente utilizar: para <span class="math notranslate nohighlight">\(\ell\)</span> de <span class="math notranslate nohighlight">\(1\)</span> a <span class="math notranslate nohighlight">\(n\)</span>:</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(temp = V_{\ell i}^{(k)}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(V_{\ell i}^{(k)} = c*temp - s*V_{\ell j}^{(k)}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(V_{\ell j}^{(k)} = s*temp + c*V_{\ell j}^{(k)}\)</span></p></li>
</ul>
</li>
</ul>
<p>con <span class="math notranslate nohighlight">\(V_{\ell i}^{(k)}\)</span> entrada <span class="math notranslate nohighlight">\(\ell, i\)</span> de <span class="math notranslate nohighlight">\(V_k\)</span>.</p>
<ul class="simple">
<li><p>El método de rotaciones de Jacobi para matrices simétricas utiliza como criterios de paro:</p>
<ul>
<li><p>La cantidad <span class="math notranslate nohighlight">\(num\text{_}columnas\text{_}ortogonales\)</span>.</p></li>
<li><p>Número máximo de <em>sweeps</em>. Un <em>sweep</em> consiste de como máximo <span class="math notranslate nohighlight">\(\frac{n(n-1)}{2}\)</span> rotaciones (pues depende de cuántas columnas son o no ortogonales) y en cada <em>sweep</em> se ortogonalizan <span class="math notranslate nohighlight">\(2\)</span> columnas. El criterio de paro es de la forma:</p></li>
</ul>
</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">num_columnas_ortogonales</span> <span class="o">!=</span> <span class="n">n</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">sweeps</span> <span class="o">&lt;</span> <span class="n">max_sweeps</span>
</pre></div>
</div>
<p>con <code class="docutils literal notranslate"><span class="pre">sweeps</span></code> contador de los <em>sweeps</em>.</p>
<ul class="simple">
<li><p>Al finalizar el método, los valores singulares calculados son las normas Euclidianas de cada columna de <span class="math notranslate nohighlight">\(A_k\)</span> y las columnas normalizadas de <span class="math notranslate nohighlight">\(A_k\)</span> son las columnas de <span class="math notranslate nohighlight">\(U\)</span>.</p></li>
<li><p>En esencia el método de rotaciones de Jacobi <em>one sided</em> con ordenamiento cíclico por renglones está realizando lo siguiente por ejemplo para una matriz de <span class="math notranslate nohighlight">\(4\times 4\)</span>:</p></li>
</ul>
<p>En el primer <em>sweep</em> se trabajan las columnas <span class="math notranslate nohighlight">\(1\)</span> y <span class="math notranslate nohighlight">\(2\)</span> para el par de índices <span class="math notranslate nohighlight">\((1,2)\)</span>:</p>
<ol class="simple">
<li><p>Se revisa si las columnas son ortogonales, si lo son se incrementa en un contador.</p></li>
<li><p>Si no son ortogonales entonces se ortogonalizan con el producto <span class="math notranslate nohighlight">\(AJ\)</span> y se acumula las rotaciones con el producto <span class="math notranslate nohighlight">\(VJ\)</span>.</p></li>
</ol>
<p>Se repiten los pasos <span class="math notranslate nohighlight">\(1\)</span> y <span class="math notranslate nohighlight">\(2\)</span> para las columnas en los índices <span class="math notranslate nohighlight">\((1,3), (1,4), (2,3), (2,4), (3,4)\)</span>.</p>
<p>En el segundo <em>sweep</em> se repite lo del primer <em>sweep</em></p>
<p>Hasta convergencia.</p>
<p>Con el producto <span class="math notranslate nohighlight">\(AJ\)</span> se converge a una matriz <span class="math notranslate nohighlight">\(W\)</span> con la que se obtendrán <span class="math notranslate nohighlight">\(U, \Sigma\)</span> y con el producto <span class="math notranslate nohighlight">\(VJ\)</span> se converge a la matriz <span class="math notranslate nohighlight">\(V\)</span> de la SVD.</p>
<p>(En la descripción anterior se omite el subíndice <span class="math notranslate nohighlight">\(k\)</span> por facilidad).</p>
</div>
<div class="tip admonition">
<p class="admonition-title">Ejercicios</p>
<p>1.Resuelve los ejercicios y preguntas de la nota.</p>
</div>
<p><strong>Preguntas de comprehensión</strong></p>
<p>1)¿Cómo se podría calcular el rank de una matriz si se han calculado previamente sus valores singulares?</p>
<p>2)Verdadero o falso:</p>
<p>a. Las columnas de la matriz V en la SVD de una matriz A, son eigenvectores de la matriz AA^T.</p>
<p>b. Si el rank de una matriz es r, entonces las columnas r+1 a m de la matriz U en la SVD de la matriz A de tamaño mxn nos dan una base del espacio nulo izquierdo de A.</p>
<p>c. La norma 2 de una matriz A es el mínimo valor singular de A.</p>
<p>3)¿Cuál es la mejor aproximación a una matriz A bajo la norma de Frobenius que se puede obtener sobre el espacio de matrices de rank igual a t ?</p>
<p>4)Menciona características y diferencias que tiene la <em>eigen decomposition</em> y la SVD de una matriz A (suponemos existe una <em>eigen decomposition</em>).</p>
<p>5)Menciona métodos numéricos para calcular la SVD de una matriz.</p>
<p>6)Menciona aplicaciones de la SVD de una matriz.</p>
<p><strong>Referencias</strong></p>
<ol class="simple">
<li><p>L. Trefethen, D. Bau, Numerical linear algebra, SIAM, 1997.</p></li>
<li><p>G. H. Golub, C. F. Van Loan, Matrix Computations, John Hopkins University Press, 2013.</p></li>
<li><p>C. Meyer, Matrix Analysis and Applied Linear Algebra, SIAM, 2000.</p></li>
</ol>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "palmoreck/dockerfiles-for-binder",
            ref: "jupyterlab_optimizacion_2",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./2.computo_matricial/2.4"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="../2.3/Algoritmos_y_aplicaciones_de_eigenvalores_eigenvectores_de_una_matriz.html" title="previous page">2.3 Algoritmos y aplicaciones de eigenvalores y eigenvectores de una matriz</a>
    <a class='right-next' id="next-link" href="../../3.optimizacion_convexa/3.1/Definicion_de_problema_optimizacion_conjuntos_y_funciones_convexas.html" title="next page">3.1 Definición de problemas de optimización, conjuntos y funciones convexas</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Erick Palacios Moreno<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>